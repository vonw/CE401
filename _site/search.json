[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Notebooks",
    "section": "",
    "text": "Computational Notebooks\n© Von P. Walden, Washington State University\nThese computational notebooks were developed by Von P. Walden at Washington State University as part of the course CE401 - Climate Change Science and Engineering. Some of the notebooks are closely associated with Andrew Dessler’s book, Introduction to Modern Climate Change, and are designed to provide engineering students with more background in how to calculate parameters that are related to Earth’s climate and climate change.",
    "crumbs": [
      "Computational Notebooks"
    ]
  },
  {
    "objectID": "chapter2.html",
    "href": "chapter2.html",
    "title": "Is the Climate Changing?",
    "section": "",
    "text": "Is the Climate Changing?\nChapter 2 includes the following computational notebooks: - Estimating the amount of sea level rise generated from melting of the Laurentide Ice Sheet - Viewing temperature anomalies generated by the Berkeley Earth project"
  },
  {
    "objectID": "chapter4/ASHRAE_Irradiance.html",
    "href": "chapter4/ASHRAE_Irradiance.html",
    "title": "ASHRAE Irradiance sample calculation",
    "section": "",
    "text": "ASHRAE Irradiance sample calculation\n\nimport numpy as np\nimport pandas as pd\nimport hvplot.pandas\n\nimport matplotlib.pyplot as plt\n\nASHRAE provides a formula for calculating the irradiance at the surface on a plane that is perpendicular to the incoming solar radiation. This equation is:\n\\[ I_B = A e^{-Km} \\]\nwhere\n\\[ A = 1160 + 75 sin[360(n - 275)/365] \\]\n\\[ K = 0.174 + 0.035 sin[360(n - 100)/365] \\]\n\\[ m = 1/ sin(\\beta) \\]\n\\[ \\beta = 90 - Latitude + Declination \\]\n\\[ Declination = \\delta = 23.45 sin[360/365 (n - 81)] \\]\nand n is the day number (e.g., May 1 = 31 + 28 + 31 + 30 + 1 = 121). A is the irradiance (W m-2), K is the attenuation per air mass, and m is the air mass.\n\ndef declination(day):\n    d = -23.44 * np.cos( (2.*np.pi) / 365.25 * (day + 10) )   # Approximate\n    return d\n\n\ndef declination(day):\n    d = 23.44 * np.cos( (2.*np.pi) / 365.25 * (day - 81) )   # Approximate\n    return d\n\n\ndef A(n):\n    return 1160. + 75.*np.sin(360/365*(n-275)*np.pi/180) # W m-2\n\n\ndef K(n):\n    return 0.174 +0.035*np.sin(360/365*(n-100)*np.pi/180) # unitless\n\n\ndef m(latitude, declination):\n    return 1. / np.sin((90. - latitude + declination)*np.pi/180)\n\n\ndays = np.arange(0,366)\ndec = []\nfor day in days:\n    dec.append(declination(day))\ndec = np.array(dec)\n\nplt.figure(figsize=(12,6))\nplt.plot(days, dec)\nplt.grid();\nplt.xlabel('Day of Year');\nplt.ylabel('Declination');\n\n\n\n\n\n\n\n\n\nA(121)\n\n1124.6630369244601\n\n\n\nK(121)\n\n0.186378664276173\n\n\n\ndeclination(121)\n\n14.788451200638994\n\n\n\nm(46.73, declination(121))\n\n1.1784278038586675\n\n\n\nlat = 46.73\nday = 121\ndec = declination(day)\nIb = A(day) * np.exp(-K(day)*m(lat, dec))\nprint('The ASHRAE irradiance at the surface is %4.0f W m-2'% Ib)\n\nThe ASHRAE irradiance at the surface is  903 W m-2\n\n\n\nNow create an annual cycle of solar radiation\n\ndates = pd.date_range('2023-01-01', '2023-12-31', freq='d')\n\n\ndec = []\nIb  = []\nfor date in dates:\n    day = int(date.strftime('%-j'))\n    dec.append(declination(day))\n    Ib.append(A(day) * np.exp(-K(day)*m(lat, dec[-1])))\ndec = np.array(dec)\ndf = pd.DataFrame({'declination': dec, 'irradiance': Ib})\ndf.index = dates\n\n\ndf.declination.plot(figsize=(16,6), grid=True)\n\n\n\n\n\n\n\n\n\ndf.irradiance.plot(figsize=(16,6), grid=True)\n\n\n\n\n\n\n\n\nNOTE THAT this is the solar radiation (in W m-2) on a surface that is always perpendicular to the sunlight. This is quite different from the TOA insolation that we calculated before. See the figures in the Solar Radiation Calculator for another example."
  },
  {
    "objectID": "chapter4/Insolation.html",
    "href": "chapter4/Insolation.html",
    "title": "Insolation",
    "section": "",
    "text": "© Von P. Walden, Washington State University\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n\n\n\\[Q = S_o (d_m/d)^2 \\cos(\\theta_s)\\] where So is the solar “constant”, dm is the mean distance between the Earth and Sun, d is the actual distance between the Earth and Sun, and theta(s) is the solar zenith angle.\n\\(\\delta = -23.44^{\\circ}\\cos{[(t_j+10 days)*(360^{\\circ}/365.25 days)]}\\) is the declination angle.\n\\(\\cos{\\theta_s} = \\sin{\\phi}sin{\\delta} + \\cos{\\phi}\\cos{\\delta}\\cos{h}\\), where phi is the latitude and h is the hour angle.\n\\(h=(12-t)*(15^{\\circ} / 1 hour)\\), where t is the local time and 15 is the number of degrees that the Earth rotates in one hour. The conversion factor converts hours to degrees.\n$ d_m $ is the mean distance from the Sun to the Earth, and is equal to the length of semi-major axis (a) of the elliptical orbit (which is 149.6 million km).\nd is the distance between the Earth and Sun on any given day, where the closest approach (perihelion) occurs on 3 January.\n\\[ d = \\frac{a(1-\\epsilon^2)}{1 + \\epsilon cos(\\theta)} \\]\nwhere $ $ is the eccentricity of Earth’s orbit (0.017), a is the semi major axis of Earth’s orbit, and $ $ is an angle that relates the day number to the correct location of Earth in the elliptical orbit for that day.\n\\(Q_{dayavg} = (S_o/\\pi)(d_m/d)^2[h_o\\sin{\\phi}\\sin{\\delta}+\\cos{\\phi}\\cos{\\delta}\\sin{h_o}]\\), where cos(\\(h_o) = -\\tan{\\phi}\\tan{\\delta}\\).\n\ndef earth_sun_distance(day):\n    a     = 149.6e6                   # km\n    e     = 0.017\n    theta = (day - 3) * ((2*np.pi) / 365.25)     # This is only an approximation.\n    d = a*(1-e*e)/(1+e * np.cos(theta))\n    return d\n\n\ndef declination(day):\n    dec = -23.44 * np.cos( (2.*np.pi) / 365.25 * (day + 10) )   # Approximate\n    return dec\n\n\ndef solar_zenith_angle(latitude,declinationAngle,hour):\n    # All angles must be in radians !!\n    latitude = latitude * (np.pi/180.)\n    declinationAngle = declinationAngle * (np.pi/180.)\n    h = 15. * (12. - hour) * (np.pi/180.)\n    sza = np.arccos(np.sin(latitude)*np.sin(declinationAngle) + np.cos(latitude)*np.cos(declinationAngle)*np.cos(h))\n    return sza\n\n\ndef Qday_avg(latitude,day):\n    lat = latitude*(np.pi/180.)\n    So  = 1370.\n    d   = earth_sun_distance(day)\n    dm  = 149.6e6\n    da  = declination(day) * (np.pi/180.)\n    tmp = np.tan(lat)*np.tan(da)\n    # Obtain this condition from http://en.wikipedia.org/wiki/Insolation\n    if tmp&gt;1:\n        ho = np.pi\n    elif tmp&lt;-1:\n        ho = 0.\n    else:\n        ho  = np.arccos(-1.*np.tan(lat)*np.tan(da))\n    Q   = (So/np.pi) * (dm/d)**2 * (ho*np.sin(lat)*np.sin(da) + np.cos(lat)*np.cos(da)*np.sin(ho))\n    return Q\n\n\nlat = 46.7\nday = 31+28+22\nprint('Declination = ', declination(day))\nprint('Earth distance = ', earth_sun_distance(day))\nprint('Q =', Qday_avg(lat, day))\n\nDeclination =  -0.12600714770976626\nEarth distance =  148981817.36070523\nQ = 300.456485702979\n\n\n\n\n\n\n\nlats = np.arange(-90.,91.)\ndays = np.arange(1.,366.)\n\nQ = np.array([])\nfor lat in lats:\n    for day in days:\n        Q = np.append(Q, Qday_avg(lat,day))\n\nQn = np.reshape(Q,(181,365))\nplt.figure(figsize=(20,10))\n#CS=contourf(days, lats, Qn, range(0,550,50), cmap=plt.cm.RdBu_r)\nCS=plt.contour(days, lats, Qn, range(0,550,25), colors='k')\nplt.clabel(CS, range(0,550,100) ,inline=1,fmt='%4.0f',fontsize=12)\nplt.grid()\nplt.xlabel('Day of Year');\nplt.ylabel('Latitude (deg)');\nplt.title('TOA Insolation as a function of Day of Year and Latitude');\n\n\n\n\n\n\n\n\n\nmar20 = 31+28+20\njun21 = 31+28+31+30+31+21\nsep20 = 31+28+31+30+31+30+31+31+20\ndec21 = 355\nplt.figure(figsize=(20,10))\nplt.plot(lats,Qn[:,jun21],'r',lats,Qn[:,dec21],'b')\nplt.plot(lats,Qn[:,mar20],'r--',lats,Qn[:,sep20],'b--')\n#plt.plot(lats,Qn.mean(axis=1),'k')                      # Annual mean\nplt.axis([-90., 90., 0., 600])\nplt.grid()\nplt.xticks(np.arange(-90., 90.+1, 30.))\nplt.xlabel('Latitude (degrees)');\nplt.ylabel('Insolation (W m-2)');\nplt.title('Insolation for the Solstices and Equinoxes');\nplt.legend(['June Solstice', 'December Solstice', 'March Equinox', 'September Equinox'])\n\n\n\n\n\ndays = np.arange(1.,366.)\nlat  = 46.7298\nlon  = -117.1817\n\nQ = np.array([])\nfor day in days:\n    Q = np.append(Q, Qday_avg(lat,day))\n\nplt.figure(figsize=(12,6))\nplt.plot(days, Q)\nplt.grid()\nplt.xlabel('Day of Year')\nplt.ylabel('Daily-Average Insolation (W m-2)')\nplt.title('TOA Insolation over Pullman, WA')\n\nText(0.5, 1.0, 'TOA Insolation over Pullman, WA')"
  },
  {
    "objectID": "chapter4/Insolation.html#calculates-the-insolation-at-the-top-of-the-atmosphere-toa-as-a-function-of-time-and-location.",
    "href": "chapter4/Insolation.html#calculates-the-insolation-at-the-top-of-the-atmosphere-toa-as-a-function-of-time-and-location.",
    "title": "Insolation",
    "section": "",
    "text": "\\[Q = S_o (d_m/d)^2 \\cos(\\theta_s)\\] where So is the solar “constant”, dm is the mean distance between the Earth and Sun, d is the actual distance between the Earth and Sun, and theta(s) is the solar zenith angle.\n\\(\\delta = -23.44^{\\circ}\\cos{[(t_j+10 days)*(360^{\\circ}/365.25 days)]}\\) is the declination angle.\n\\(\\cos{\\theta_s} = \\sin{\\phi}sin{\\delta} + \\cos{\\phi}\\cos{\\delta}\\cos{h}\\), where phi is the latitude and h is the hour angle.\n\\(h=(12-t)*(15^{\\circ} / 1 hour)\\), where t is the local time and 15 is the number of degrees that the Earth rotates in one hour. The conversion factor converts hours to degrees.\n$ d_m $ is the mean distance from the Sun to the Earth, and is equal to the length of semi-major axis (a) of the elliptical orbit (which is 149.6 million km).\nd is the distance between the Earth and Sun on any given day, where the closest approach (perihelion) occurs on 3 January.\n\\[ d = \\frac{a(1-\\epsilon^2)}{1 + \\epsilon cos(\\theta)} \\]\nwhere $ $ is the eccentricity of Earth’s orbit (0.017), a is the semi major axis of Earth’s orbit, and $ $ is an angle that relates the day number to the correct location of Earth in the elliptical orbit for that day.\n\\(Q_{dayavg} = (S_o/\\pi)(d_m/d)^2[h_o\\sin{\\phi}\\sin{\\delta}+\\cos{\\phi}\\cos{\\delta}\\sin{h_o}]\\), where cos(\\(h_o) = -\\tan{\\phi}\\tan{\\delta}\\).\n\ndef earth_sun_distance(day):\n    a     = 149.6e6                   # km\n    e     = 0.017\n    theta = (day - 3) * ((2*np.pi) / 365.25)     # This is only an approximation.\n    d = a*(1-e*e)/(1+e * np.cos(theta))\n    return d\n\n\ndef declination(day):\n    dec = -23.44 * np.cos( (2.*np.pi) / 365.25 * (day + 10) )   # Approximate\n    return dec\n\n\ndef solar_zenith_angle(latitude,declinationAngle,hour):\n    # All angles must be in radians !!\n    latitude = latitude * (np.pi/180.)\n    declinationAngle = declinationAngle * (np.pi/180.)\n    h = 15. * (12. - hour) * (np.pi/180.)\n    sza = np.arccos(np.sin(latitude)*np.sin(declinationAngle) + np.cos(latitude)*np.cos(declinationAngle)*np.cos(h))\n    return sza\n\n\ndef Qday_avg(latitude,day):\n    lat = latitude*(np.pi/180.)\n    So  = 1370.\n    d   = earth_sun_distance(day)\n    dm  = 149.6e6\n    da  = declination(day) * (np.pi/180.)\n    tmp = np.tan(lat)*np.tan(da)\n    # Obtain this condition from http://en.wikipedia.org/wiki/Insolation\n    if tmp&gt;1:\n        ho = np.pi\n    elif tmp&lt;-1:\n        ho = 0.\n    else:\n        ho  = np.arccos(-1.*np.tan(lat)*np.tan(da))\n    Q   = (So/np.pi) * (dm/d)**2 * (ho*np.sin(lat)*np.sin(da) + np.cos(lat)*np.cos(da)*np.sin(ho))\n    return Q\n\n\nlat = 46.7\nday = 31+28+22\nprint('Declination = ', declination(day))\nprint('Earth distance = ', earth_sun_distance(day))\nprint('Q =', Qday_avg(lat, day))\n\nDeclination =  -0.12600714770976626\nEarth distance =  148981817.36070523\nQ = 300.456485702979"
  },
  {
    "objectID": "chapter4/Insolation.html#geographic-distribution-of-insolation-solar-radition-at-toa",
    "href": "chapter4/Insolation.html#geographic-distribution-of-insolation-solar-radition-at-toa",
    "title": "Insolation",
    "section": "",
    "text": "lats = np.arange(-90.,91.)\ndays = np.arange(1.,366.)\n\nQ = np.array([])\nfor lat in lats:\n    for day in days:\n        Q = np.append(Q, Qday_avg(lat,day))\n\nQn = np.reshape(Q,(181,365))\nplt.figure(figsize=(20,10))\n#CS=contourf(days, lats, Qn, range(0,550,50), cmap=plt.cm.RdBu_r)\nCS=plt.contour(days, lats, Qn, range(0,550,25), colors='k')\nplt.clabel(CS, range(0,550,100) ,inline=1,fmt='%4.0f',fontsize=12)\nplt.grid()\nplt.xlabel('Day of Year');\nplt.ylabel('Latitude (deg)');\nplt.title('TOA Insolation as a function of Day of Year and Latitude');\n\n\n\n\n\n\n\n\n\nmar20 = 31+28+20\njun21 = 31+28+31+30+31+21\nsep20 = 31+28+31+30+31+30+31+31+20\ndec21 = 355\nplt.figure(figsize=(20,10))\nplt.plot(lats,Qn[:,jun21],'r',lats,Qn[:,dec21],'b')\nplt.plot(lats,Qn[:,mar20],'r--',lats,Qn[:,sep20],'b--')\n#plt.plot(lats,Qn.mean(axis=1),'k')                      # Annual mean\nplt.axis([-90., 90., 0., 600])\nplt.grid()\nplt.xticks(np.arange(-90., 90.+1, 30.))\nplt.xlabel('Latitude (degrees)');\nplt.ylabel('Insolation (W m-2)');\nplt.title('Insolation for the Solstices and Equinoxes');\nplt.legend(['June Solstice', 'December Solstice', 'March Equinox', 'September Equinox'])"
  },
  {
    "objectID": "chapter4/Insolation.html#daily-average-insolation-over-pullman-wa",
    "href": "chapter4/Insolation.html#daily-average-insolation-over-pullman-wa",
    "title": "Insolation",
    "section": "",
    "text": "days = np.arange(1.,366.)\nlat  = 46.7298\nlon  = -117.1817\n\nQ = np.array([])\nfor day in days:\n    Q = np.append(Q, Qday_avg(lat,day))\n\nplt.figure(figsize=(12,6))\nplt.plot(days, Q)\nplt.grid()\nplt.xlabel('Day of Year')\nplt.ylabel('Daily-Average Insolation (W m-2)')\nplt.title('TOA Insolation over Pullman, WA')\n\nText(0.5, 1.0, 'TOA Insolation over Pullman, WA')"
  },
  {
    "objectID": "chapter3/BodiesEmittingInARoom.html",
    "href": "chapter3/BodiesEmittingInARoom.html",
    "title": "Bodies Emitting in a Room",
    "section": "",
    "text": "Bodies Emitting in a Room\n© Von P. Walden, Washington State University\n\nStefan-Boltzmann constant\n\ns = 5.67e-8                     # W m-2 K-4\n\n\n\nRadiation from the walls of the room\n\nTroom = 20 + 273.15             # K\nFlux_room = s * Troom**4            # W m-2\n\nprint(f\"The room radiates approximately {Flux_room:5.1f} W m-2\")\n\n\n\nRadiation from the bodies in the room\n\nTbody = 28 + 273.15             # K\nFlux_body = s * Tbody**4            # W m-2\n\nprint(f\"Bodies radiate at approximately {Flux_body:5.1f} W m-2\")\n\n\nActual Body Temperature (in deg C)\n\n(37 * 9/5) + 32\n\n\n\n\nRadiation from the bodies in the room (including emissivity)\n\ne     = 0.89\nTbody = 37 + 273.15             # K\nFlux_body = e * s * Tbody**4            # W m-2\n\nprint(f\"Bodies radiate at approximately {Flux_body:5.1f} W m-2\")\n\n\nSo if the emissivity of our bodies is 0.89 (or 89%), then we emit the same radiation as a blackbody at 28 C."
  },
  {
    "objectID": "chapter3/PowerEmittedByHuman.html",
    "href": "chapter3/PowerEmittedByHuman.html",
    "title": "Calculate the Power Emitted by a Human",
    "section": "",
    "text": "Calculate the Power Emitted by a Human\n© Von P. Walden, Washington State University\nEstimate the power (in W) given off by an average human being if they consume 2000 calories of food each day.\n\ncalories_per_day   = 2000\njoules_per_calorie = 4184\nseconds_per_day    = 24 * 60 * 60\n\npower_per_human    = calories_per_day * joules_per_calorie / seconds_per_day\n\n\nprint(f'The power emitted by an average human is {power_per_human:{4.3}} W m-2')"
  },
  {
    "objectID": "chapter2/LaurentideIceSheet_and_SeaLevel.html",
    "href": "chapter2/LaurentideIceSheet_and_SeaLevel.html",
    "title": "Approximate the Decrease in Sea-level from the Laurentide Ice Sheet",
    "section": "",
    "text": "© Von P. Walden, Washington State University\nThis notebook does a quick calculation of how much ice was contained in the Laurentide Ice Sheet about 20,000 years ago, and how that may have affected sea level at that time.\n\n# Approximate the volume of water in the Laurentide Ice Sheet\nsurface_area_of_Canada     = 10e6       # km^2\naverage_height_of_icesheet = 1.750      # km\nvolume_of_ice              = surface_area_of_Canada * average_height_of_icesheet\n\n# Assume the density of ice in the Laurentide\nrho_ice                    = 917        # kg m-3\nrho_water                  = 1000       # kg m-3\n\nvolume_of_water            = volume_of_ice * (rho_water / rho_ice)\n\n\nprint(\"The estimated volume of water in the Laurentide ice sheet is:\", volume_of_water, \"km^3\")\n\nThe estimated volume of water in the Laurentide ice sheet is: 19083969.465648852 km^3\n\n\n\n# Now divide by the surface area of oceans on earth to get the depth of water required to create the ice sheet.\nsurface_area_of_oceans     = 361e6        # km^2\nsea_level_change           = volume_of_water / surface_area_of_oceans * 1000   # meters\n\n\nprint(f'Decrease in sea level due to the Laurentide Ice Sheet: {sea_level_change:{5.3}} meters')\n\nDecrease in sea level due to the Laurentide Ice Sheet:  52.9 meters\n\n\n\n\nSea Level Rise, After the Ice Melted and Today\n\n\nSo find the necessary density of ice to get 120 meters of sea level.\n\nnew_rho_of_ice = volume_of_ice * (rho_water) / (surface_area_of_oceans * 120/1000)\n\n\nnew_rho_of_ice\n\n403.97045244690673",
    "crumbs": [
      "Chapter 2",
      "Approximate the Decrease in Sea-level from the Laurentide Ice Sheet"
    ]
  },
  {
    "objectID": "chapter2/LaurentideIceSheet_and_SeaLevel.html#the-actual-value-at-the-height-of-the-last-ice-age-was-actually-about-120-meters.",
    "href": "chapter2/LaurentideIceSheet_and_SeaLevel.html#the-actual-value-at-the-height-of-the-last-ice-age-was-actually-about-120-meters.",
    "title": "Approximate the Decrease in Sea-level from the Laurentide Ice Sheet",
    "section": "",
    "text": "Sea Level Rise, After the Ice Melted and Today\n\n\nSo find the necessary density of ice to get 120 meters of sea level.\n\nnew_rho_of_ice = volume_of_ice * (rho_water) / (surface_area_of_oceans * 120/1000)\n\n\nnew_rho_of_ice\n\n403.97045244690673",
    "crumbs": [
      "Chapter 2",
      "Approximate the Decrease in Sea-level from the Laurentide Ice Sheet"
    ]
  },
  {
    "objectID": "chapter3.html",
    "href": "chapter3.html",
    "title": "Radiation and Energy Balance",
    "section": "",
    "text": "Radiation and Energy Balance\nChapter 3 includes the following computational notebooks: - Planck’s Law (recreation of figures of Planck curves in Chapter 3) - Radiation emitted in various spectral bands - Power emitted by humans - Bodies emitting in a room"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Computational Notebooks",
    "section": "",
    "text": "Computational Notebooks\n© Von P. Walden, Washington State University\nThese computational notebooks were developed by Von P. Walden at Washington State University as part of the course CE401 - Climate Change Science and Engineering. Some of the notebooks are closely associated with Andrew Dessler’s book, Introduction to Modern Climate Change, and are designed to provide engineering students with more background in how to calculate parameters that are related to Earth’s climate and climate change."
  },
  {
    "objectID": "chapter0/softwareCarpentry_AnalyzingPatientData.html",
    "href": "chapter0/softwareCarpentry_AnalyzingPatientData.html",
    "title": "Software Carpentry - Analyzing Patient Data",
    "section": "",
    "text": "Software Carpentry - Analyzing Patient Data\nRead Software Carpentry’s Analyzing Patient Data.\nUsing notebook cells below, type in the commands in the instructions to check your knowledge of Python variables. (The two cells below will get you started.)\n\nimport numpy\n\n\nnumpy.loadtxt(fname='inflammation-01.csv', delimiter=',')",
    "crumbs": [
      "Chapter 0",
      "Software Carpentry - Analyzing Patient Data"
    ]
  },
  {
    "objectID": "chapter4.html",
    "href": "chapter4.html",
    "title": "A Simple Climate Model",
    "section": "",
    "text": "A Simple Climate Model\n\nCalculation of the Solar “Constant”\nInsolation as a function of latitude and longitude\nInfrared Absorption by Earth’s Atmosphere\nEquilibrium Temperature of Earth"
  },
  {
    "objectID": "chapter0.html",
    "href": "chapter0.html",
    "title": "Using Python",
    "section": "",
    "text": "Using Python\nChapter 0 includes the following computational notebooks: - Software Carpentry’s Python Fundamentals - Software Carpentry’s Analyzing Patient Data"
  },
  {
    "objectID": "chapter1.html",
    "href": "chapter1.html",
    "title": "An Introduction to the Climate Problem",
    "section": "",
    "text": "An Introduction to the Climate Problem\nChapter 1 includes the following computational notebooks: - Comparing two temperature distributions for Fairbanks, Alaska"
  },
  {
    "objectID": "chapter10.html",
    "href": "chapter10.html",
    "title": "Exponential Growth",
    "section": "",
    "text": "Exponential Growth\nChapter 10 includes the following computational notebooks: - Exponential growth"
  },
  {
    "objectID": "chapter1/HoustonTemperatures.html",
    "href": "chapter1/HoustonTemperatures.html",
    "title": "Comparing temperature distributions",
    "section": "",
    "text": "Comparing temperature distributions\n© Von P. Walden, Washington State University\nThis notebook compares two distributions that differ slightly in their mean values. The idea is to simulate the two distributions in Figure 1.1 in Dessler’s book, and to then subtract the distributions to show where they differ the most.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nimport statistics\n\n\nGenerate two distributions of temperatures that approximate those measured in Houston, TX in the 1970s and 2010s.\n\n# ....These distributions roughly approximate those in Figure 1.1 in Dessler's Introduction to Modern Climate Change\nx = np.arange(21, 43, 0.1)\nH1970s = norm.pdf(x, 31, 2.75)\nH2010s = norm.pdf(x, 33, 2.75)\n\n\nplt.figure(figsize=(12,12))\nplt.subplot(211)\nplt.plot(x, H1970s)\nplt.plot(x, H2010s)\nplt.grid(True)\nplt.xlabel('Temperature (C)')\nplt.ylabel('Frequency')\nplt.title('Approximate Temperature Distributions for September near Houston, TX')\nplt.legend(['1970s', '2010s'])\nplt.subplot(212)\nplt.plot(x, H2010s-H1970s)\nplt.xlabel('Temperature (C)')\nplt.ylabel('Frequency')\nplt.title('Difference of the two temperature distributions')\nplt.grid(True)",
    "crumbs": [
      "Chapter 1",
      "Comparing temperature distributions"
    ]
  },
  {
    "objectID": "chapter0/softwareCarpentry_PythonFundamentals.html",
    "href": "chapter0/softwareCarpentry_PythonFundamentals.html",
    "title": "Software Carpentry - Python Fundamentals",
    "section": "",
    "text": "Software Carpentry - Python Fundamentals\nRead Software Carpentry’s Python Fundamentals. Start by scrolling down to the section on Variables.\nUsing notebook cells below, type in the commands in the instructions to check your knowledge of Python variables. (The cell below is the first example.)\n\n3 + 5 * 4",
    "crumbs": [
      "Chapter 0",
      "Software Carpentry - Python Fundamentals"
    ]
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html",
    "href": "chapter10/ExponentialGrowth_Dessler.html",
    "title": "Exponential Growth",
    "section": "",
    "text": "import numpy as np\n\n\n\n\\[ F = P (1 + rate/100)^n \\]\nwhere F is the future values, P is the initial value, rate is the percentage rate of increase (interest), and n is the number of years.\n\nP = 100\nrate = 10\nn = 101\nF = P * (1 + rate/100)**n\n\nprint('Wow! That $100 investment really grew! It is $' + f'{F:.2f}' + ' after 101 years!')\n\nWow! That $100 investment really grew! It is $1515867.36 after 101 years!\n\n\n\n\n\nTo determine the doubling time, one can recognize that F/P is 2. So, then one can determine n if the rate is known.\n\\[ \\frac{F}{P} = 2 = (1 + r)^n \\]\nwhere r is the fractional rate of increase (not the percentage)\nTake the natural log of both sides of the equation.\n\\[ ln(2) = ln[(1 + r)^n] = n * ln(1 + r) \\]\nSo,\n\\[ n = \\frac{ln(2)}{ln(1 + r)} \\]\n\\[ n = \\frac{ln(2)}{r} \\frac{r}{ln(1 + r)} \\]\nIf r is small (e.g., 8% = 0.08), then\n\\[ \\frac{r}{ln(1 + r)} = \\frac{0.08}{ln(1 + 0.08)} = 1.03949 \\]\nand\n\\[ n \\approx \\frac{0.72}{r} \\approx \\frac{72}{100 * r} \\]\n\nr = 0.08\nnp.log(2) * r / np.log(1 + r)\n\n0.7205174673600471\n\n\nSo, if the rate of interest is constant at 7.2%, it will take 10 years to double your money.\n\n\n\n\n\nDiscounting simply solves our original equation for P.\n\\[ P = \\frac{F}{(1 + rate/100)^n} \\]\nThe value today of a future expense or benefit is known as the present value. The process of calculating the present value is referred to as discounting. “Money today is worth more to you than money in the future.”\n\n\n\nHow much would we need to invest to have $25,000 in 15 years at a 5% interest rate.\n\nF = 25000\nrate = 5\nn = 15\nP = F / (1 + rate/100)**n\n\nprint(f'We would need to invest ${P:.2f} now (at 5%) to have $25000 in 15 years.')\nprint()\nprint(f'${P:.2f} is the present value.')\nprint('This calculation is called discounting.')\nprint()\nprint('The rate of 5% is called the discount rate, because it quantifies the rate at which money loses value in the future.')\nprint('In other words, money loses 5% of its value each year.')\n\nWe would need to invest $12025.43 now (at 5%) to have $25000 in 15 years.\n\n$12025.43 is the present value.\nThis calculation is called discounting.\n\nThe rate of 5% is called the discount rate, because it quantifies the rate at which money loses value in the future.\nIn other words, money loses 5% of its value each year.\n\n\n\n\n\n\nDiscounting can be used to help make financial decisions.\nLet’s say you’re buying a new TV and you’re given two payment options:\n\nPay $1000. now.\nGet it with no money down and pay $1100. in 1 year.\n\nWhich option is best for you?\n\n# No discounting.\nprint('You pay $1000. now, so it costs you $1000. in dollars today. So, the present value is $1000.')\n\nYou pay $1000. now, so it costs you $1000. in dollars today. So, the present value is $1000.\n\n\nBut what is the present value of $1100. in one year.\n\n# Discount option at 5% in one year\nP = 1000\ndiscountRate = 5\nn = 1\nF = P * (1 + discountRate/100)**n\n\nprint('The value of the money after 1 year AT A DISCOUNT RATE OF 5% is $' + f'{F:.2f}')\n\nThe value of the money after 1 year AT A DISCOUNT RATE OF 5% is $1050.00\n\n\nThe option that costs you the least amount of money is the one with the lowest present value.\nTherefore, you choose to pay $1000. now (because the present value of $1100. in one year from now, discounted at 5%, is $1050.)\nBut what is the discount rate is higher, say 15%?\n\nF = 1100\ndiscountRate = 15\nn = 1\nP = F / (1 + discountRate/100)**n\n\nprint('The value of the money after 1 year AT A DISCOUNT RATE OF 15% is $' + f'{P:.2f}')\n\nThe value of the money after 1 year AT A DISCOUNT RATE OF 15% is $956.52\n\n\nNow the option that costs you the least amount of money is the present value using the 15% discount rate.\nTherefore, you choose to pay $1100. next because it will only cost you $956 in today’s dollars.\n\n\n\n\n\n\n\nImagine our choice is between spending $100 billion today or $1 trillion in 100 years. Compare these two using a discount rate of 3%.\n\nrate = 3\nF = 1e12\nn = 100\nP = F / (1 + rate/100)**n\n\nprint('The value of the money after 100 years AT A DISCOUNT RATE OF 3% is $' + f'{P:.2f}')\n\nThe value of the money after 100 years AT A DISCOUNT RATE OF 3% is $52032839850.21\n\n\nNote that this equals only $52 billion, so we would prefer to pay $1 trillion in 100 years than pay $100 billion today\n\n\n\n\n\nThe discount rate is a combination of two different judgements:\n\nTime discounting, which is the preference to consume now rather than later. Positive time discounting means that goods and services now are worth more than they are later.\nGrowth discounting is the fact that a dollar means more to poor people than it does to rich people. Would you pick up a $1 bill if you saw it on the street? What about a $20 bill?\n\nThe discount rate used in present-value calculations is determined by combining the time and growth discount rates.\nBUT economists argue about which rate to use: 1% to 4%."
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html#examples-from-introduction-to-modern-climate-change-by-andrew-dessler",
    "href": "chapter10/ExponentialGrowth_Dessler.html#examples-from-introduction-to-modern-climate-change-by-andrew-dessler",
    "title": "Exponential Growth",
    "section": "",
    "text": "import numpy as np\n\n\n\n\\[ F = P (1 + rate/100)^n \\]\nwhere F is the future values, P is the initial value, rate is the percentage rate of increase (interest), and n is the number of years.\n\nP = 100\nrate = 10\nn = 101\nF = P * (1 + rate/100)**n\n\nprint('Wow! That $100 investment really grew! It is $' + f'{F:.2f}' + ' after 101 years!')\n\nWow! That $100 investment really grew! It is $1515867.36 after 101 years!\n\n\n\n\n\nTo determine the doubling time, one can recognize that F/P is 2. So, then one can determine n if the rate is known.\n\\[ \\frac{F}{P} = 2 = (1 + r)^n \\]\nwhere r is the fractional rate of increase (not the percentage)\nTake the natural log of both sides of the equation.\n\\[ ln(2) = ln[(1 + r)^n] = n * ln(1 + r) \\]\nSo,\n\\[ n = \\frac{ln(2)}{ln(1 + r)} \\]\n\\[ n = \\frac{ln(2)}{r} \\frac{r}{ln(1 + r)} \\]\nIf r is small (e.g., 8% = 0.08), then\n\\[ \\frac{r}{ln(1 + r)} = \\frac{0.08}{ln(1 + 0.08)} = 1.03949 \\]\nand\n\\[ n \\approx \\frac{0.72}{r} \\approx \\frac{72}{100 * r} \\]\n\nr = 0.08\nnp.log(2) * r / np.log(1 + r)\n\n0.7205174673600471\n\n\nSo, if the rate of interest is constant at 7.2%, it will take 10 years to double your money."
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html#discounting",
    "href": "chapter10/ExponentialGrowth_Dessler.html#discounting",
    "title": "Exponential Growth",
    "section": "",
    "text": "Discounting simply solves our original equation for P.\n\\[ P = \\frac{F}{(1 + rate/100)^n} \\]\nThe value today of a future expense or benefit is known as the present value. The process of calculating the present value is referred to as discounting. “Money today is worth more to you than money in the future.”\n\n\n\nHow much would we need to invest to have $25,000 in 15 years at a 5% interest rate.\n\nF = 25000\nrate = 5\nn = 15\nP = F / (1 + rate/100)**n\n\nprint(f'We would need to invest ${P:.2f} now (at 5%) to have $25000 in 15 years.')\nprint()\nprint(f'${P:.2f} is the present value.')\nprint('This calculation is called discounting.')\nprint()\nprint('The rate of 5% is called the discount rate, because it quantifies the rate at which money loses value in the future.')\nprint('In other words, money loses 5% of its value each year.')\n\nWe would need to invest $12025.43 now (at 5%) to have $25000 in 15 years.\n\n$12025.43 is the present value.\nThis calculation is called discounting.\n\nThe rate of 5% is called the discount rate, because it quantifies the rate at which money loses value in the future.\nIn other words, money loses 5% of its value each year.\n\n\n\n\n\n\nDiscounting can be used to help make financial decisions.\nLet’s say you’re buying a new TV and you’re given two payment options:\n\nPay $1000. now.\nGet it with no money down and pay $1100. in 1 year.\n\nWhich option is best for you?\n\n# No discounting.\nprint('You pay $1000. now, so it costs you $1000. in dollars today. So, the present value is $1000.')\n\nYou pay $1000. now, so it costs you $1000. in dollars today. So, the present value is $1000.\n\n\nBut what is the present value of $1100. in one year.\n\n# Discount option at 5% in one year\nP = 1000\ndiscountRate = 5\nn = 1\nF = P * (1 + discountRate/100)**n\n\nprint('The value of the money after 1 year AT A DISCOUNT RATE OF 5% is $' + f'{F:.2f}')\n\nThe value of the money after 1 year AT A DISCOUNT RATE OF 5% is $1050.00\n\n\nThe option that costs you the least amount of money is the one with the lowest present value.\nTherefore, you choose to pay $1000. now (because the present value of $1100. in one year from now, discounted at 5%, is $1050.)\nBut what is the discount rate is higher, say 15%?\n\nF = 1100\ndiscountRate = 15\nn = 1\nP = F / (1 + discountRate/100)**n\n\nprint('The value of the money after 1 year AT A DISCOUNT RATE OF 15% is $' + f'{P:.2f}')\n\nThe value of the money after 1 year AT A DISCOUNT RATE OF 15% is $956.52\n\n\nNow the option that costs you the least amount of money is the present value using the 15% discount rate.\nTherefore, you choose to pay $1100. next because it will only cost you $956 in today’s dollars.\n\n\n\n\n\n\n\nImagine our choice is between spending $100 billion today or $1 trillion in 100 years. Compare these two using a discount rate of 3%.\n\nrate = 3\nF = 1e12\nn = 100\nP = F / (1 + rate/100)**n\n\nprint('The value of the money after 100 years AT A DISCOUNT RATE OF 3% is $' + f'{P:.2f}')\n\nThe value of the money after 100 years AT A DISCOUNT RATE OF 3% is $52032839850.21\n\n\nNote that this equals only $52 billion, so we would prefer to pay $1 trillion in 100 years than pay $100 billion today"
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html#so-how-do-we-determine-the-correct-discount-rate-to-use",
    "href": "chapter10/ExponentialGrowth_Dessler.html#so-how-do-we-determine-the-correct-discount-rate-to-use",
    "title": "Exponential Growth",
    "section": "",
    "text": "The discount rate is a combination of two different judgements:\n\nTime discounting, which is the preference to consume now rather than later. Positive time discounting means that goods and services now are worth more than they are later.\nGrowth discounting is the fact that a dollar means more to poor people than it does to rich people. Would you pick up a $1 bill if you saw it on the street? What about a $20 bill?\n\nThe discount rate used in present-value calculations is determined by combining the time and growth discount rates.\nBUT economists argue about which rate to use: 1% to 4%."
  },
  {
    "objectID": "homework.html",
    "href": "homework.html",
    "title": "Homework",
    "section": "",
    "text": "Homework\nThis section contains Python code that is useful for homework assignments in CE401."
  },
  {
    "objectID": "chapter2/plotBerkeleyEarth.html",
    "href": "chapter2/plotBerkeleyEarth.html",
    "title": "Plot global temperature anomalies from Berkeley Earth",
    "section": "",
    "text": "Plot global temperature anomalies from Berkeley Earth\n© Von P. Walden, Washington State University\nThe data used in this notebook are from Berkeley Earth: Land_and_Ocean_LatLong1.nc\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport pandas as pd\nimport xarray as xr\n\n\nWorking from your local computer\nIf you are running this notebook from your local computer, you will need to:\n\nDownload a large (400 MB) data file from Berkeley Earth by clicking on this link\nEdit the code cell below by replacing ‘../Land_and_Ocean_LatLong1.nc’ with the pathname to the data file on your local hard drive.\n\n\nbe = xr.open_dataset('../../Land_and_Ocean_LatLong1.nc')\n#be = xr.open_dataset('/Users/vonw/work/courses/2021-2022/spring/CE401/jupyterbook/CE401/Land_and_Ocean_LatLong1.nc')\nbe\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt;\nDimensions:      (longitude: 360, latitude: 180, time: 2064, month_number: 12)\nCoordinates:\n  * longitude    (longitude) float32 -179.5 -178.5 -177.5 ... 177.5 178.5 179.5\n  * latitude     (latitude) float32 -89.5 -88.5 -87.5 -86.5 ... 87.5 88.5 89.5\n  * time         (time) float64 1.85e+03 1.85e+03 ... 2.022e+03 2.022e+03\nDimensions without coordinates: month_number\nData variables:\n    land_mask    (latitude, longitude) float64 ...\n    temperature  (time, latitude, longitude) float32 ...\n    climatology  (month_number, latitude, longitude) float32 ...\nAttributes:\n    Conventions:  Berkeley Earth Internal Convention (based on CF-1.5)\n    title:        Native Format Berkeley Earth Surface Temperature Anomaly Field\n    institution:  Berkeley Earth Surface Temperature Project\n    comment:      This file contains surface temperature anomaly field gridde...xarray.DatasetDimensions:longitude: 360latitude: 180time: 2064month_number: 12Coordinates: (3)longitude(longitude)float32-179.5 -178.5 ... 178.5 179.5units :degrees_eaststandard_name :longitudelong_name :Longitudearray([-179.5, -178.5, -177.5, ...,  177.5,  178.5,  179.5], dtype=float32)latitude(latitude)float32-89.5 -88.5 -87.5 ... 88.5 89.5units :degrees_northstandard_name :latitudelong_name :Latitudearray([-89.5, -88.5, -87.5, -86.5, -85.5, -84.5, -83.5, -82.5, -81.5, -80.5,\n       -79.5, -78.5, -77.5, -76.5, -75.5, -74.5, -73.5, -72.5, -71.5, -70.5,\n       -69.5, -68.5, -67.5, -66.5, -65.5, -64.5, -63.5, -62.5, -61.5, -60.5,\n       -59.5, -58.5, -57.5, -56.5, -55.5, -54.5, -53.5, -52.5, -51.5, -50.5,\n       -49.5, -48.5, -47.5, -46.5, -45.5, -44.5, -43.5, -42.5, -41.5, -40.5,\n       -39.5, -38.5, -37.5, -36.5, -35.5, -34.5, -33.5, -32.5, -31.5, -30.5,\n       -29.5, -28.5, -27.5, -26.5, -25.5, -24.5, -23.5, -22.5, -21.5, -20.5,\n       -19.5, -18.5, -17.5, -16.5, -15.5, -14.5, -13.5, -12.5, -11.5, -10.5,\n        -9.5,  -8.5,  -7.5,  -6.5,  -5.5,  -4.5,  -3.5,  -2.5,  -1.5,  -0.5,\n         0.5,   1.5,   2.5,   3.5,   4.5,   5.5,   6.5,   7.5,   8.5,   9.5,\n        10.5,  11.5,  12.5,  13.5,  14.5,  15.5,  16.5,  17.5,  18.5,  19.5,\n        20.5,  21.5,  22.5,  23.5,  24.5,  25.5,  26.5,  27.5,  28.5,  29.5,\n        30.5,  31.5,  32.5,  33.5,  34.5,  35.5,  36.5,  37.5,  38.5,  39.5,\n        40.5,  41.5,  42.5,  43.5,  44.5,  45.5,  46.5,  47.5,  48.5,  49.5,\n        50.5,  51.5,  52.5,  53.5,  54.5,  55.5,  56.5,  57.5,  58.5,  59.5,\n        60.5,  61.5,  62.5,  63.5,  64.5,  65.5,  66.5,  67.5,  68.5,  69.5,\n        70.5,  71.5,  72.5,  73.5,  74.5,  75.5,  76.5,  77.5,  78.5,  79.5,\n        80.5,  81.5,  82.5,  83.5,  84.5,  85.5,  86.5,  87.5,  88.5,  89.5],\n      dtype=float32)time(time)float641.85e+03 1.85e+03 ... 2.022e+03units :year A.D.standard_name :timelong_name :Timearray([1850.041667, 1850.125   , 1850.208333, ..., 2021.791667, 2021.875   ,\n       2021.958333])Data variables: (3)land_mask(latitude, longitude)float64...units :nonestandard_name :land_masklong_name :Land Maskvalid_min :0.0valid_max :1.0[64800 values with dtype=float64]temperature(time, latitude, longitude)float32...units :degree Cstandard_name :surface_temperature_anomalylong_name :Air Surface Temperature Anomalyvalid_min :-20.13358547046764valid_max :25.779894588495726[133747200 values with dtype=float32]climatology(month_number, latitude, longitude)float32...units :degree Cstandard_name :surface_temperature_climatologylong_name :Air Surface Temperature Climatology (Jan 1951 - Dec 1980)valid_min :-68.87224481059923valid_max :38.21117653490976[777600 values with dtype=float32]Indexes: (3)longitudePandasIndexPandasIndex(Float64Index([-179.5, -178.5, -177.5, -176.5, -175.5, -174.5, -173.5, -172.5,\n              -171.5, -170.5,\n              ...\n               170.5,  171.5,  172.5,  173.5,  174.5,  175.5,  176.5,  177.5,\n               178.5,  179.5],\n             dtype='float64', name='longitude', length=360))latitudePandasIndexPandasIndex(Float64Index([-89.5, -88.5, -87.5, -86.5, -85.5, -84.5, -83.5, -82.5, -81.5,\n              -80.5,\n              ...\n               80.5,  81.5,  82.5,  83.5,  84.5,  85.5,  86.5,  87.5,  88.5,\n               89.5],\n             dtype='float64', name='latitude', length=180))timePandasIndexPandasIndex(Float64Index([1850.0416666666667,           1850.125, 1850.2083333333333,\n              1850.2916666666667,           1850.375, 1850.4583333333333,\n              1850.5416666666667,           1850.625, 1850.7083333333333,\n              1850.7916666666667,\n              ...\n              2021.2083333333333, 2021.2916666666665,           2021.375,\n              2021.4583333333333, 2021.5416666666665,           2021.625,\n              2021.7083333333333, 2021.7916666666665,           2021.875,\n              2021.9583333333333],\n             dtype='float64', name='time', length=2064))Attributes: (4)Conventions :Berkeley Earth Internal Convention (based on CF-1.5)title :Native Format Berkeley Earth Surface Temperature Anomaly Fieldinstitution :Berkeley Earth Surface Temperature Projectcomment :This file contains surface temperature anomaly field gridded on a 1� (longitude) by 1� (latitude) grid-box basis.\n\n\n\n\nPlot geographic distribution of 1951-1980 climatology\n\n# Select a particular month to view\nmonth = 'Jan'\n#month = 'Jul'\n\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nfig = plt.figure(figsize=(20,10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\nbe.climatology[months.index(month)].plot(ax=ax)\nplt.title('Climatology (1951-1980) for ' + month);\n\n\n\n\n\n\n\n\n\n\nPlot geographic distribution of temperature anomalies for given year and month\n\n# Select a particular year and month to view\nyear = 1900\nmonth = 'Jan'\n#month = 'Jul'\n\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nfig = plt.figure(figsize=(20,10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\n(be.temperature[months.index(month)+((year-1850)*12)]).plot(ax=ax, clim=[-10, 10])\nplt.title('Temperature Anomalies for ' + month + ' ' + str(year));\n\n\n\n\n\n\n\n\n\n\nPlot geographic distribution of actual temperatures for given year and month\n\n# Select a particular year and month to view\nyear = 1990\nmonth = 'Jan'\n#month = 'Jul'\n\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nfig = plt.figure(figsize=(20,10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\n(be.temperature[months.index(month)+((year-1850)*12)] + be.climatology[months.index(month)]).plot(ax=ax, clim=[-10, 10])\nplt.title('Temperatures for ' + month + ' ' + str(year));\n\n\n\n\n\n\n\n\n\n\nCalculate global annual temperature anomalies\n\n# Select a particular year and month to view\n# !! Depending on how many years you choose to analyze, this COULD TAKE TENS OF SECONDS to complete.\nbeginning_year = 1850\nending_year = 2010\n\nmonths = pd.date_range(start=str(beginning_year), end=str(ending_year+1), freq='M')\n\ndata = []\nfor month in months:\n    #print(month.month)\n    data.append(be.temperature[month.month+((month.year-1850)*12)].mean())\n\nTanomalies = xr.DataArray(data, coords={'month': months})\n\nfig = plt.figure(figsize=(20,10))\nTanomalies.plot()\nplt.grid()\nplt.xlabel('Month');\nplt.ylabel('Temperature anomaly (C)');\nplt.title('Global monthly temperature anomaly between ' + str(beginning_year) + ' and ' + str(ending_year));\n\n\n\n\n\n\n\n\n\n\nCalculate longitudinally-averaged temperature anomalies\n\n# Select the latitude range to average over\nbeginning_latitude = -5\nending_latitude = 5\n\n# Select a particular year and month to view\n# !! Depending on how many years you choose to analyze, this COULD TAKE TENS OF SECONDS to complete.\nbeginning_year = 1950\nending_year = 2020\n\nmonths = pd.date_range(start=str(beginning_year), end=str(ending_year+1), freq='M')\n\ndata = []\nfor month in months:\n    #print(month.month)\n    data.append(be.temperature[month.month+((month.year-1850)*12)].sel(latitude=slice(beginning_latitude, ending_latitude)).mean())\n\nTanomalies = xr.DataArray(data, coords={'month': months})\n\nfig = plt.figure(figsize=(20,10))\nTanomalies.plot()\nplt.grid()\nplt.xlabel('Month');\nplt.ylabel('Temperature anomaly (C)');\nplt.title('Equatorial temperature anomaly between ' + str(beginning_year) + ' and ' + str(ending_year));"
  },
  {
    "objectID": "chapter3/PlancksLaw.html",
    "href": "chapter3/PlancksLaw.html",
    "title": "Calculate Planck curves as a function of wavelength and temperature",
    "section": "",
    "text": "© Von P. Walden, Washington State University\n\n%pylab inline\n\n%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib\n\n\n\n\n\nc  = 2.998e8                              # m s-1\nh  = 6.626e-34                            # m2 kg s-1\nkB = 1.381e-23                            # m2 kg s-2 K-1\nl  = np.arange(0.25,20,0.25) * 1e-6       # meters\nT  = 300.                                 # K\nB  = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux  = pi * B\n\n\nplot(l/1e-6,spectralFlux)\nxlabel('Wavelength, microns');\nylabel('Spectral Flux, W m-2 um-1');\ntext(17.5,30,'300 K');\n\n\n\n\n\n\n\n\n\nl_max = l[np.where(spectralFlux==spectralFlux.max())]\nprint(l_max)\n\n[9.75e-06]\n\n\n\nprint(f\"Wiens Law gives wavelength of maximum flux at: {(2989/T):3.1f} um.\")\n\nWiens Law gives wavelength of maximum flux at: 10.0 um.\n\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")\n\nThe Stefan-Boltzmann Law gives the total flux for this object as:  459 W m-2.\n\n\n\n\n\n\nl = np.arange(0.25,12,0.05) * 1e-6      # meters\nT = 1600.                               # K\nB = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux = pi * B                   # W m-2 um-1\n\n\nplot(l/1e-6,spectralFlux)\nxlabel('Wavelength, microns');\nylabel('Spectral Flux, W m-2 um-1');\ntext(10,120000,'1600 K');\n\n\nprint(f\"Wiens law gives wavelength of maximum flux at: {(2989/T):3.1f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")\n\n\n\n\n\nl  = np.arange(0.01,3.5,0.01) * 1e-6      # meters\nT  = 6000.                                # K\nB  = pi * 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\n\n\nplot(l/1e-6,B)\nxlabel('Wavelength, microns');\nylabel('Flux, W m-2 um-1');\ntext(2.8,90e6,'6000 K');\n\n\nprint(f\"Wiens law gives wavelength of maximum flux at: {(2989/T):3.1f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")"
  },
  {
    "objectID": "chapter3/PlancksLaw.html#dessler-figure-3.2a",
    "href": "chapter3/PlancksLaw.html#dessler-figure-3.2a",
    "title": "Calculate Planck curves as a function of wavelength and temperature",
    "section": "",
    "text": "c  = 2.998e8                              # m s-1\nh  = 6.626e-34                            # m2 kg s-1\nkB = 1.381e-23                            # m2 kg s-2 K-1\nl  = np.arange(0.25,20,0.25) * 1e-6       # meters\nT  = 300.                                 # K\nB  = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux  = pi * B\n\n\nplot(l/1e-6,spectralFlux)\nxlabel('Wavelength, microns');\nylabel('Spectral Flux, W m-2 um-1');\ntext(17.5,30,'300 K');\n\n\n\n\n\n\n\n\n\nl_max = l[np.where(spectralFlux==spectralFlux.max())]\nprint(l_max)\n\n[9.75e-06]\n\n\n\nprint(f\"Wiens Law gives wavelength of maximum flux at: {(2989/T):3.1f} um.\")\n\nWiens Law gives wavelength of maximum flux at: 10.0 um.\n\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")\n\nThe Stefan-Boltzmann Law gives the total flux for this object as:  459 W m-2."
  },
  {
    "objectID": "chapter3/PlancksLaw.html#dessler-figure-3.2b",
    "href": "chapter3/PlancksLaw.html#dessler-figure-3.2b",
    "title": "Calculate Planck curves as a function of wavelength and temperature",
    "section": "",
    "text": "l = np.arange(0.25,12,0.05) * 1e-6      # meters\nT = 1600.                               # K\nB = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux = pi * B                   # W m-2 um-1\n\n\nplot(l/1e-6,spectralFlux)\nxlabel('Wavelength, microns');\nylabel('Spectral Flux, W m-2 um-1');\ntext(10,120000,'1600 K');\n\n\nprint(f\"Wiens law gives wavelength of maximum flux at: {(2989/T):3.1f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")"
  },
  {
    "objectID": "chapter3/PlancksLaw.html#dessler-figure-3.2c",
    "href": "chapter3/PlancksLaw.html#dessler-figure-3.2c",
    "title": "Calculate Planck curves as a function of wavelength and temperature",
    "section": "",
    "text": "l  = np.arange(0.01,3.5,0.01) * 1e-6      # meters\nT  = 6000.                                # K\nB  = pi * 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\n\n\nplot(l/1e-6,B)\nxlabel('Wavelength, microns');\nylabel('Flux, W m-2 um-1');\ntext(2.8,90e6,'6000 K');\n\n\nprint(f\"Wiens law gives wavelength of maximum flux at: {(2989/T):3.1f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")"
  },
  {
    "objectID": "chapter3/RadiationInSpectralBands.html",
    "href": "chapter3/RadiationInSpectralBands.html",
    "title": "Calculate Percentage of Radiation in Spectral Bands",
    "section": "",
    "text": "Calculate Percentage of Radiation in Spectral Bands\n© Von P. Walden, Washington State University\n\nimport numpy as np\nimport xarray as xr\n\n\nFor a given temperature T, calculate the proportion of radiation emitted in various spectral bands (UV, visible, near-infrared, and infrared).\n\n# Temperature of the object\n#T  = 5700.                                 # K\nT  = 3300.                                 # K\n#T  = 300.                                  # K\n\n\n# Calculate the Planck radiation distribution between 0 and 50 microns\nc  = 2.998e8                              # m s-1\nh  = 6.626e-34                            # m2 kg s-1\nkB = 1.381e-23                            # m2 kg s-2 K-1\ndl = 0.01                                 # meters\nl  = np.arange(dl,50,dl) * 1e-6           # meters\nB  = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux  = np.pi * B      # W m-2 um-1\n\n# Convert spectralFlux to an Xarray data array\nspectralFlux = xr.DataArray(spectralFlux, coords={'wavelength': l*1e6}, dims=['wavelength'])\n\n# Sum the radiation in uv, vis, nir and ir spectral bands:\n#     UV            = 0   to 0.3 microns\n#     visible       = 0.3 to 0.7 microns\n#     near infrared = 0.7 to 4 microns\n#     infrared      = 4   to 50 microns\nuv  = spectralFlux.sel(wavelength=slice(0,0.3)).sum()*dl\nvis = spectralFlux.sel(wavelength=slice(0.3,0.7)).sum()*dl\nnir = spectralFlux.sel(wavelength=slice(0.7,4)).sum()*dl\nir  = spectralFlux.sel(wavelength=slice(4,50)).sum()*dl\n\n# Calculate the percent contribution in each band\nFlux  = spectralFlux.sum()*dl                           # Total flux in W m-2; Should be nearly equal to sigma * T^4 !!\np_uv  = uv / Flux * 100\np_vis = vis / Flux * 100\np_nir = nir / Flux * 100\np_ir  = ir / Flux * 100\n\n\n#%% Sum all the spectral bands; should be close to 100% !!\nprint('Percent UV:            ', p_uv.values)\nprint('Percent visible:       ', p_vis.values)\nprint('Percent near infrared: ', p_nir.values)\nprint('Percent infrared:      ', p_ir.values)\n\nprint('Total percent:         ', p_uv.values + p_vis.values + p_nir.values + p_ir.values)"
  },
  {
    "objectID": "chapter4/EquilibriumTemperatureOfEarth.html",
    "href": "chapter4/EquilibriumTemperatureOfEarth.html",
    "title": "Calculation of the Equilibrium Temperature of Earth",
    "section": "",
    "text": "Calculation of the Equilibrium Temperature of Earth\n\nEquation 4.3(b) in Dessler.\n\nS = 1360                  # W m-2\na = 0.3                   # unitless\nTequilibrium = (S*(1-a)/(4*5.67e-8))**(1/4)\n\n\nprint('The Equilibrium Temperature of Earth is:', Tequilibrium, 'K')"
  },
  {
    "objectID": "chapter4/SolarConstant.html",
    "href": "chapter4/SolarConstant.html",
    "title": "Calculation of the Solar Constant",
    "section": "",
    "text": "© Von P. Walden, Washington State University\n\n\n\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n\n\n\nTsun = 5772                   # K; chosen to yield S = 1361 W m-2\nE    = 5.67e-8 * Tsun**4        # W m-2\nprint('The flux from the Sun is:',E, 'W m-2')\n\nThe flux from the Sun is: 62934436.58666411 W m-2\n\n\n\n\n\n\nRs   = 695.7e6                    # meters\nAs   = 4*np.pi*Rs**2                 # m2\nPsun = E * As\nprint('Power emitted by the Sun is:', Psun, 'Watts')\n\nPower emitted by the Sun is: 3.8277381380933445e+26 Watts\n\n\n\n\n\n\n# Average radius of Earth's orbit around the Sun.\nRes   = 149.6e9                    # meters\n# Surface area of a sphere with radius equal to Re.\nAes   = 4*np.pi*Res**2                # m2\n# Solar Constant\nS     = Psun / Aes\nprint('The Solar Constant for Earth is:', S, 'W m-2')\n\nThe Solar Constant for Earth is: 1361.0346073015646 W m-2\n\n\n\n\n\n\n\nRe   = 6.4e6                        # meters\nAint = np.pi*Re**2                     # Area intercepted by Earth in m2\nPe   = S * Aint\nprint('The amount of power (in Watts) that is constantly intercepted by Earth is:', Pe, 'Watts')\n\nThe amount of power (in Watts) that is constantly intercepted by Earth is: 1.7513743661383942e+17 Watts\n\n\n\n\n\n\nprint('The amount of power (in TW) that is constantly intercepted by Earth is:', Pe/1e12, 'TW')\n\nThe amount of power (in TW) that is constantly intercepted by Earth is: 175137.4366138394 TW\n\n\n\n\n\n\n\n\na = 0.3                               # Earth's albedo; unitless\nS*(1-a)/4\n\n238.1810562777738\n\n\n\n\n\nS/4\n\n340.25865182539115\n\n\n\n\n\n\n\n\nSensRes                   = pd.DataFrame({'Earth-Sun Distance': [147.1e9,149.6e9,152.1e9]})\nSensRes['Area']           = 4 * np.pi * SensRes['Earth-Sun Distance']**2\nSensRes['Solar Constant'] = Psun / SensRes['Area']\nSensRes['% difference']   = (SensRes['Solar Constant'] - SensRes['Solar Constant'].iloc[1]) / SensRes['Solar Constant'].iloc[1] * 100\nSensRes\n\n\n\n\n\n\n\n\nTsun = np.array([5772, 5773.5])   # K; chosen to yield S = 1361 W m-2\nE    = 5.67e-8 * Tsun**4        # W m-2\nRs   = 695.7e6                  # meters\nAs   = 4*np.pi*Rs**2               # m2\nPsun = E * As\n# Average radius of Earth's orbit around the Sun.\nRes   = 149.6e9                 # meters\n# Surface area of a sphere with radius equal to Re.\nAes   = 4*np.pi*Res**2             # m2\n# Solar Constant\nS     = Psun / Aes\n\nSensTsun = pd.DataFrame({'Temperature of Sun':   Tsun,\n                         'Power Emitted by Sun': Psun,\n                         'Solar Constant':       S,\n                         '% difference': (S-S[0])/S[1]*100})\nSensTsun[['Temperature of Sun', 'Power Emitted by Sun', 'Solar Constant', '% difference']]"
  },
  {
    "objectID": "chapter4/SolarConstant.html#useful-links",
    "href": "chapter4/SolarConstant.html#useful-links",
    "title": "Calculation of the Solar Constant",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\n\n\n\n\n\nTsun = 5772                   # K; chosen to yield S = 1361 W m-2\nE    = 5.67e-8 * Tsun**4        # W m-2\nprint('The flux from the Sun is:',E, 'W m-2')\n\nThe flux from the Sun is: 62934436.58666411 W m-2\n\n\n\n\n\n\nRs   = 695.7e6                    # meters\nAs   = 4*np.pi*Rs**2                 # m2\nPsun = E * As\nprint('Power emitted by the Sun is:', Psun, 'Watts')\n\nPower emitted by the Sun is: 3.8277381380933445e+26 Watts\n\n\n\n\n\n\n# Average radius of Earth's orbit around the Sun.\nRes   = 149.6e9                    # meters\n# Surface area of a sphere with radius equal to Re.\nAes   = 4*np.pi*Res**2                # m2\n# Solar Constant\nS     = Psun / Aes\nprint('The Solar Constant for Earth is:', S, 'W m-2')\n\nThe Solar Constant for Earth is: 1361.0346073015646 W m-2\n\n\n\n\n\n\n\nRe   = 6.4e6                        # meters\nAint = np.pi*Re**2                     # Area intercepted by Earth in m2\nPe   = S * Aint\nprint('The amount of power (in Watts) that is constantly intercepted by Earth is:', Pe, 'Watts')\n\nThe amount of power (in Watts) that is constantly intercepted by Earth is: 1.7513743661383942e+17 Watts\n\n\n\n\n\n\nprint('The amount of power (in TW) that is constantly intercepted by Earth is:', Pe/1e12, 'TW')\n\nThe amount of power (in TW) that is constantly intercepted by Earth is: 175137.4366138394 TW"
  },
  {
    "objectID": "chapter4/SolarConstant.html#as-dessler-explains-all-of-human-society-currently-consumes-only-16-tw.-so-we-only-need-to-capture-0.01-of-the-suns-power-to-meet-all-of-our-energy-needs.",
    "href": "chapter4/SolarConstant.html#as-dessler-explains-all-of-human-society-currently-consumes-only-16-tw.-so-we-only-need-to-capture-0.01-of-the-suns-power-to-meet-all-of-our-energy-needs.",
    "title": "Calculation of the Solar Constant",
    "section": "",
    "text": "a = 0.3                               # Earth's albedo; unitless\nS*(1-a)/4\n\n238.1810562777738\n\n\n\n\n\nS/4\n\n340.25865182539115"
  },
  {
    "objectID": "chapter4/SolarConstant.html#sensitivity-to-earth-sun-distance",
    "href": "chapter4/SolarConstant.html#sensitivity-to-earth-sun-distance",
    "title": "Calculation of the Solar Constant",
    "section": "",
    "text": "SensRes                   = pd.DataFrame({'Earth-Sun Distance': [147.1e9,149.6e9,152.1e9]})\nSensRes['Area']           = 4 * np.pi * SensRes['Earth-Sun Distance']**2\nSensRes['Solar Constant'] = Psun / SensRes['Area']\nSensRes['% difference']   = (SensRes['Solar Constant'] - SensRes['Solar Constant'].iloc[1]) / SensRes['Solar Constant'].iloc[1] * 100\nSensRes"
  },
  {
    "objectID": "chapter4/SolarConstant.html#sensitivity-to-suns-surface-temperature.",
    "href": "chapter4/SolarConstant.html#sensitivity-to-suns-surface-temperature.",
    "title": "Calculation of the Solar Constant",
    "section": "",
    "text": "Tsun = np.array([5772, 5773.5])   # K; chosen to yield S = 1361 W m-2\nE    = 5.67e-8 * Tsun**4        # W m-2\nRs   = 695.7e6                  # meters\nAs   = 4*np.pi*Rs**2               # m2\nPsun = E * As\n# Average radius of Earth's orbit around the Sun.\nRes   = 149.6e9                 # meters\n# Surface area of a sphere with radius equal to Re.\nAes   = 4*np.pi*Res**2             # m2\n# Solar Constant\nS     = Psun / Aes\n\nSensTsun = pd.DataFrame({'Temperature of Sun':   Tsun,\n                         'Power Emitted by Sun': Psun,\n                         'Solar Constant':       S,\n                         '% difference': (S-S[0])/S[1]*100})\nSensTsun[['Temperature of Sun', 'Power Emitted by Sun', 'Solar Constant', '% difference']]"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "© Von P. Walden, Washington State University\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\nTo calculate the infrared absorption by the atmosphere, we must calculate the optical depth. The optical depth is related to the transmission of radiation through “optical media”, such as an absorbing gas or an absorbing liquid. Beer’s Law gives us\n\\[ I(\\lambda) = I_o(\\lambda) e^{-\\tau} \\]\nThis can be rewritten as\n\\[ Transmission = \\frac{I(\\lambda)}{I_o(\\lambda)} = e^{-\\tau} \\]\nThen one can solve for the optical depth \\(\\tau\\) as\n\\[ \\tau = -ln \\Big[ \\frac{I(\\lambda)}{I_o(\\lambda)} \\Big] \\]\nIn general, the optical depth is:\n\\[ \\tau = \\int_{z_1}^{z_2} \\beta_{\\lambda} dz = \\int_{z_1}^{z_2} \\kappa_{\\lambda} \\rho (z) dz = \\int_{z_1}^{z_2} \\sigma_{\\lambda} n(z) dz \\]\nwhere - \\(\\beta\\) is the volume absorption coefficient, - \\(\\kappa\\) is the mass absorption coefficient, - \\(\\sigma\\) is the absorption cross section,\nwhich all depend on wavelength, \\(\\lambda\\).\n\\(\\rho(z)\\) and n(z) are the air density and the number density of the absorbing gas. z is distance along the absorbing path from \\(z_1\\) to \\(z_2\\).\nIf one conducts an experiment of Beer’s Law in the lab using a tube filled with an absorbing gas (like H2O or CO2), this equation reduces to:\n\\[ \\tau = \\beta (z_2 - z_1) = \\kappa_{\\lambda} \\rho (z_2 - z_1) = \\sigma_{\\lambda} N (z_2 - z_1) \\]\nNote that this is how scientists (100 or so years ago) determined how different gases absorbed infrared radiation at different wavelengths, by measuring the transmission of radiation through the gas, calculating the optical depth, then solving for either \\(\\beta_{\\lambda}\\), \\(\\kappa_{\\lambda}\\), or \\(\\sigma_{\\lambda}\\).\n\n\nTo determine the optical depth in the atmosphere, one must use the general equation above, because the number of molecules of absorbing gas changes with height in the atmosphere. Carbon dioxide is “uniformly mixed” in the atmosphere, meaning that its concentration relative to other gases does not change with height. However, the actual number of CO2 molecules decreases exponentially with height in the atmosphere because the density (and pressure) of the air decreases in this manner. Most of the water vapor in the atmosphere is contained only in the troposphere in the lowest 7 or 8 km. Therefore, one must integrate through the atmosphere to determine the optical depth using:\n\\[ \\tau = \\int_{z_1}^{z_2} \\kappa_{\\lambda} \\rho (z) dz \\]\nHere we have chosen to use the specific formula of the optical depth that contains the mass absorption coefficient, because Figure 2 of Pierrehumbert (2010) gives values of \\(\\kappa\\) for both H2O and CO2.\n\n\n\n\nWe’re lucky because McClatchey et al (1972) [in Optical Properties of the Atmosphere (Third Edition)] created a series of “standard atmospheres” for different locations and seasons on Earth that give us n(z) as a function of altitude (z) in the atmosphere. The McClatchey Standard Atmospheres are for:\n\nTropics (TRP)\nMid-latitude Summer (MLS)\nMid-latitude Winter (MLW)\nSub-Arctic Summer (SAS)\nSub-Arctic Winter (SAW\n\n\n# Read in raw data files\ncolumns = ['layer', 'altitude', 'pressure', 'temperature', 'dew_point', 'density', 'h2o', 'co2', 'o3', 'n2o', 'co', 'ch4', 'o2']\ntrp = pd.read_table('../trp.dat', sep='\\s+', names=columns)\nmls = pd.read_table('../mls.dat', sep='\\s+', names=columns)\nmlw = pd.read_table('../mlw.dat', sep='\\s+', names=columns)\nsas = pd.read_table('../sas.dat', sep='\\s+', names=columns)\nsaw = pd.read_table('../saw.dat', sep='\\s+', names=columns)\n\n\nRair = 287.058        # J kg-1 K-1\n# Calculate air density\ntrp.rename({'density': 'numberDensity'})\ntrp['airDensity'] = (trp.pressure * 100) / (Rair * trp.temperature)\n\nmls.rename({'density': 'numberDensity'})\nmls['airDensity'] = (mls.pressure * 100) / (Rair * mls.temperature)\n\nmlw.rename({'density': 'numberDensity'})\nmlw['airDensity'] = (mlw.pressure * 100) / (Rair * mlw.temperature)\n\nsas.rename({'density': 'numberDensity'})\nsas['airDensity'] = (sas.pressure * 100) / (Rair * sas.temperature)\n\nsaw.rename({'density': 'numberDensity'})\nsaw['airDensity'] = (saw.pressure * 100) / (Rair * saw.temperature)\n\n\n# Interpolate the standard atmospheres to a common grid in meters with heights every 100 meters\ntrp.index = trp.altitude*1000\ntrp = trp.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nmls.index = mls.altitude*1000\nmls = mls.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nmlw.index = mlw.altitude*1000\nmlw = mlw.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nsas.index = sas.altitude*1000\nsas = sas.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nsaw.index = saw.altitude*1000\nsaw = saw.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\n\n\n\n\n\n\n\nStandard Atmosphere\nstdatm_name\n\n\n\n\nTropical\n‘trp’\n\n\nMid-Latitude Summer\n‘mls’\n\n\nMid-Latitude Winter\n‘mlw’\n\n\nSub-Arctic Summer\n‘sas’\n\n\nSub-Arctic Winter\n‘saw’\n\n\n\n\n# Change this variable to choose the model atmosphere\n# !! NOTE that the single quotation marks are important !!\n\nstdatm_name = 'mlw'\n\nif 'trp' in stdatm_name:\n    stdatm = trp\nelif 'mls' in stdatm_name:\n    stdatm = mls\nelif 'mlw' in stdatm_name:\n    stdatm = mlw\nelif 'sas' in stdatm_name:\n    stdatm = sas\nelif 'saw' in stdatm_name:\n    stdatm = saw\nelse:\n    print(\"ERROR: This standard atmosphere is NOT RECOGNIZED. Try setting stdatm_name again!!\")\n\n\n\n\n\n# Set CO2 in all Standard Atmospheres.\n#co2 = 330.   # ppmv; approximate concentration in 1971\n#co2 = 419.   # ppmv; current concentration in 2023\n#co2 = 280.   # ppmv; pre-industrial concentration\nco2 = 560.   # ppmv; doubled CO2 concentration (from pre-industrial)\n\ntrp['co2'] = mls['co2'] = mlw['co2'] = sas['co2'] = saw['co2'] = co2\n\n\n\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(20,10), nrows=1, ncols=3, sharey=True)\n\n# Pressure\ntrp.plot(ax=ax1, x='pressure', y='altitude')\nmls.plot(ax=ax1, x='pressure', y='altitude')\nmlw.plot(ax=ax1, x='pressure', y='altitude')\nsas.plot(ax=ax1, x='pressure', y='altitude')\nsaw.plot(ax=ax1, x='pressure', y='altitude')\nax1.grid()\nax1.set_xlabel('Pressure (mb)');\nax1.set_ylabel('Altitude (km)');\nax1.set_title('Atmospheric Pressure for Standard Atmospheres');\nax1.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n# Temperature\ntrp.plot(ax=ax2, x='temperature', y='altitude')\nmls.plot(ax=ax2, x='temperature', y='altitude')\nmlw.plot(ax=ax2, x='temperature', y='altitude')\nsas.plot(ax=ax2, x='temperature', y='altitude')\nsaw.plot(ax=ax2, x='temperature', y='altitude')\nax2.grid()\nax2.set_xlabel('Temperature (K)');\nax2.set_ylabel('Altitude (km)');\nax2.set_title('Temperature Profiles for Standard Atmospheres');\nax2.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n#O3\ntrp.plot(ax=ax3, x='airDensity', y='altitude')\nmls.plot(ax=ax3, x='airDensity', y='altitude')\nmlw.plot(ax=ax3, x='airDensity', y='altitude')\nsas.plot(ax=ax3, x='airDensity', y='altitude')\nsaw.plot(ax=ax3, x='airDensity', y='altitude')\nax3.grid()\nax3.set_xlabel('Density (kg m-3)');\nax3.set_ylabel('Altitude (km)');\nax3.set_title('Density of Air for Standard Atmospheres');\nax3.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n\n\n\n\n\n\n\n\n\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(20,10), nrows=1, ncols=3, sharey=True)\n\n# H2O\ntrp.plot(ax=ax1, x='h2o', y='altitude')\nmls.plot(ax=ax1, x='h2o', y='altitude')\nmlw.plot(ax=ax1, x='h2o', y='altitude')\nsas.plot(ax=ax1, x='h2o', y='altitude')\nsaw.plot(ax=ax1, x='h2o', y='altitude')\nax1.grid()\nax1.set_xlabel('Water Vapor (ppmv)');\nax1.set_ylabel('Altitude (km)');\nax1.set_title('Water Vapor concentration for Standard Atmospheres');\nax1.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n# CO2\ntrp.plot(ax=ax2, x='co2', y='altitude')\nmls.plot(ax=ax2, x='co2', y='altitude')\nmlw.plot(ax=ax2, x='co2', y='altitude')\nsas.plot(ax=ax2, x='co2', y='altitude')\nsaw.plot(ax=ax2, x='co2', y='altitude')\nax2.grid()\nax2.set_xlabel('Carbon Dioxide (ppmv)');\nax2.set_ylabel('Altitude (km)');\nax2.set_title('Carbon Dioxide concentration for Standard Atmospheres');\nax2.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n#O3\ntrp.plot(ax=ax3, x='o3', y='altitude')\nmls.plot(ax=ax3, x='o3', y='altitude')\nmlw.plot(ax=ax3, x='o3', y='altitude')\nsas.plot(ax=ax3, x='o3', y='altitude')\nsaw.plot(ax=ax3, x='o3', y='altitude')\nax3.grid()\nax3.set_xlabel('Ozone (ppmv)');\nax3.set_ylabel('Altitude (km)');\nax3.set_title('Ozone concentration for Standard Atmospheres');\nax3.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n\n\n\n\n\n\n\n\n\n\n\nNow that we have values for the air density and the concentrations of the greenhouse gases, it is easy to calculate the optical depth for individual gases.\nWe will use mass absorption coefficients for carbon dioxide at the following wavelengths (from the center of the 15-um CO2 band towards the atmospheric window between 8 and 12.5 um):\n\n\n\n\n\n\n\n\n\nType of Absorption\nWavenumber (\\(cm^{-1}\\))\nWavelength (\\(\\mu\\)m)\n\\(\\kappa_a\\) (\\(m^2 kg^{-1}\\))\n\n\n\n\nVery Strong\n667\n15\n2000\n\n\nVery Strong\n714\n14\n10\n\n\nModerate\n769\n13\n0.1\n\n\nWeak\n833\n12\n0.001\n\n\n\nThese mass absorption coefficients values were approximated from Figure 2 in Pierrehumbert, Physics Today, January 2011.\nSo, the optical depth can now be calculated for each layer of the atmosphere by multiplying the absorption cross sections (\\(\\kappa_a\\)) by the air density, and then by the thickness of the atmospheric layer, as shown in the code below (for the Mid-latitude Winter Standard Atmosphere - MLW).\nDisclaimer: Please note that this calculation of optical depth is for illustrative purposes only, and is over-simplified in the following ways:\n\nIn most cases H2O overlaps the absorption bands of all the other GH gases. (See Figure 2 of Pierrehumbert (2010); blowup of 600-670 cm-1).\nWe are neglecting how the line strengths of absorption lines depend on temperature in the atmosphere (https://hitran.org/docs/definitions-and-units/)\nWe are neglecting how the widths of absorption lines depend on both temperature and pressure (https://hitran.org/docs/definitions-and-units/)\n\nAccurate radiative transfer models of the atmosphere account for all of this issues.\n\nKa_15 = 2000\nKa_14 = 10\nKa_13 = 0.1\nKa_12 = 0.001\n\nrhoCO2 = stdatm.airDensity[:-1] * stdatm.co2[:-1]/1e6     # Convert from ppmv to percent fraction\ndz   = np.diff(stdatm.altitude) * 1000                 # Calculate the height of each layer by differencing levels; meters\n\n# Calculate and plot the optical depth at 14.6 um for CO2 for the MLW Standard Atmosphere.\nstdatm['od_15'] = Ka_15 * rhoCO2 * dz\nstdatm['od_14'] = Ka_14 * rhoCO2 * dz\nstdatm['od_13'] = Ka_13 * rhoCO2 * dz\nstdatm['od_12'] = Ka_12 * rhoCO2 * dz\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='od_15', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_14', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_13', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_12', y='altitude', logx=True, logy=True)\nax.grid()\nax.set_xlabel('Optical Depth');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Optical Depths for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstdatm['T_15'] = np.exp(-stdatm.od_15) * 100\nstdatm['T_14'] = np.exp(-stdatm.od_14) * 100\nstdatm['T_13'] = np.exp(-stdatm.od_13) * 100\nstdatm['T_12'] = np.exp(-stdatm.od_12) * 100\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='T_15', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_14', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_13', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_12', y='altitude', logx=True)\nax.axis([0.1, 120, 0, 60])\nax.grid()\nax.set_xlabel('Transmission');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Transmission for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\n\nThe above figure shows the transmission as a function of altitude in the atmosphere. But how do we calculate the transmission through the entire atmosphere?\nThere are two ways to do this:\n\nMultiply all the transmission from each layer together, or\n\n\\[ T_{total} = e^{- \\tau_1} e^{- \\tau_2} e^{- \\tau_3} ... \\]\n\nOr (because of the properties of exponents) one can just add up all the optical depths for each layer and take the exponential of that sum\n\n\\[ T_{total} = e^{- \\tau_1} e^{- \\tau_2} e^{- \\tau_3} ... = e^{- (\\tau_1 +  \\tau_2 + \\tau_3 ...)} \\]\nOption 2 is much easier for us here; see the code below.\n\n# Calculate total transmission in the atmosphere by summing all optical depths\nTtotal_15 = np.exp(-stdatm.od_15.sum())\nTtotal_14 = np.exp(-stdatm.od_14.sum())\nTtotal_13 = np.exp(-stdatm.od_13.sum())\nTtotal_12 = np.exp(-stdatm.od_12.sum())\n\n# Print results\nprint(f'Total transmission in atmosphere (%) at 15 um = {Ttotal_15*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 14 um = {Ttotal_14*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 13 um = {Ttotal_13*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 12 um = {Ttotal_12*100:.2f} %')\n\nTotal transmission in atmosphere (%) at 15 um = 0.00 %\nTotal transmission in atmosphere (%) at 14 um = 0.00 %\nTotal transmission in atmosphere (%) at 13 um = 55.59 %\nTotal transmission in atmosphere (%) at 12 um = 99.41 %\n\n\n\n\n\n\nAn important property of thermal radiation is given by Kirchhoff’s Law. It states that\n\"For an arbitrary body emitting and absorbing thermal radiation in thermodynamic equilibrium, the emissivity is equal to the absorptivity.\"\nWe don’t have time to discuss this in CE401, but it states that a good emitter (high emissivity object) is an equally good absorber.\nThis holds true for the atmosphere as well. So, if we calculate the absorption of the atmosphere as\n\\[ Absorption = 1 - Transmission \\]\nthen also\n\\[ Emissivity = 1 - Transmission \\]\n\n\n\nstdatm['A_15'] = (1. - np.exp(-stdatm.od_15)) * 100        # Convert from fraction to percent\nstdatm['A_14'] = (1. - np.exp(-stdatm.od_14)) * 100\nstdatm['A_13'] = (1. - np.exp(-stdatm.od_13)) * 100\nstdatm['A_12'] = (1. - np.exp(-stdatm.od_12)) * 100\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='A_15', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_14', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_13', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_12', y='altitude', logx=True)\nax.grid()\nax.set_xlabel('Absorption');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Absorption for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\n\n\n# Print results\nprint(f'Total absorption in atmosphere (%) at 15 um = {(1 - Ttotal_15)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 14 um = {(1 - Ttotal_14)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 13 um = {(1 - Ttotal_13)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 12 um = {(1 - Ttotal_12)*100:.2f} %')\n\nTotal absorption in atmosphere (%) at 15 um = 100.00 %\nTotal absorption in atmosphere (%) at 14 um = 100.00 %\nTotal absorption in atmosphere (%) at 13 um = 44.41 %\nTotal absorption in atmosphere (%) at 12 um = 0.59 %"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#definition-of-the-optical-depth",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#definition-of-the-optical-depth",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "To calculate the infrared absorption by the atmosphere, we must calculate the optical depth. The optical depth is related to the transmission of radiation through “optical media”, such as an absorbing gas or an absorbing liquid. Beer’s Law gives us\n\\[ I(\\lambda) = I_o(\\lambda) e^{-\\tau} \\]\nThis can be rewritten as\n\\[ Transmission = \\frac{I(\\lambda)}{I_o(\\lambda)} = e^{-\\tau} \\]\nThen one can solve for the optical depth \\(\\tau\\) as\n\\[ \\tau = -ln \\Big[ \\frac{I(\\lambda)}{I_o(\\lambda)} \\Big] \\]\nIn general, the optical depth is:\n\\[ \\tau = \\int_{z_1}^{z_2} \\beta_{\\lambda} dz = \\int_{z_1}^{z_2} \\kappa_{\\lambda} \\rho (z) dz = \\int_{z_1}^{z_2} \\sigma_{\\lambda} n(z) dz \\]\nwhere - \\(\\beta\\) is the volume absorption coefficient, - \\(\\kappa\\) is the mass absorption coefficient, - \\(\\sigma\\) is the absorption cross section,\nwhich all depend on wavelength, \\(\\lambda\\).\n\\(\\rho(z)\\) and n(z) are the air density and the number density of the absorbing gas. z is distance along the absorbing path from \\(z_1\\) to \\(z_2\\).\nIf one conducts an experiment of Beer’s Law in the lab using a tube filled with an absorbing gas (like H2O or CO2), this equation reduces to:\n\\[ \\tau = \\beta (z_2 - z_1) = \\kappa_{\\lambda} \\rho (z_2 - z_1) = \\sigma_{\\lambda} N (z_2 - z_1) \\]\nNote that this is how scientists (100 or so years ago) determined how different gases absorbed infrared radiation at different wavelengths, by measuring the transmission of radiation through the gas, calculating the optical depth, then solving for either \\(\\beta_{\\lambda}\\), \\(\\kappa_{\\lambda}\\), or \\(\\sigma_{\\lambda}\\).\n\n\nTo determine the optical depth in the atmosphere, one must use the general equation above, because the number of molecules of absorbing gas changes with height in the atmosphere. Carbon dioxide is “uniformly mixed” in the atmosphere, meaning that its concentration relative to other gases does not change with height. However, the actual number of CO2 molecules decreases exponentially with height in the atmosphere because the density (and pressure) of the air decreases in this manner. Most of the water vapor in the atmosphere is contained only in the troposphere in the lowest 7 or 8 km. Therefore, one must integrate through the atmosphere to determine the optical depth using:\n\\[ \\tau = \\int_{z_1}^{z_2} \\kappa_{\\lambda} \\rho (z) dz \\]\nHere we have chosen to use the specific formula of the optical depth that contains the mass absorption coefficient, because Figure 2 of Pierrehumbert (2010) gives values of \\(\\kappa\\) for both H2O and CO2."
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#the-mcclatchey-standard-atmospheres",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#the-mcclatchey-standard-atmospheres",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "We’re lucky because McClatchey et al (1972) [in Optical Properties of the Atmosphere (Third Edition)] created a series of “standard atmospheres” for different locations and seasons on Earth that give us n(z) as a function of altitude (z) in the atmosphere. The McClatchey Standard Atmospheres are for:\n\nTropics (TRP)\nMid-latitude Summer (MLS)\nMid-latitude Winter (MLW)\nSub-Arctic Summer (SAS)\nSub-Arctic Winter (SAW\n\n\n# Read in raw data files\ncolumns = ['layer', 'altitude', 'pressure', 'temperature', 'dew_point', 'density', 'h2o', 'co2', 'o3', 'n2o', 'co', 'ch4', 'o2']\ntrp = pd.read_table('../trp.dat', sep='\\s+', names=columns)\nmls = pd.read_table('../mls.dat', sep='\\s+', names=columns)\nmlw = pd.read_table('../mlw.dat', sep='\\s+', names=columns)\nsas = pd.read_table('../sas.dat', sep='\\s+', names=columns)\nsaw = pd.read_table('../saw.dat', sep='\\s+', names=columns)\n\n\nRair = 287.058        # J kg-1 K-1\n# Calculate air density\ntrp.rename({'density': 'numberDensity'})\ntrp['airDensity'] = (trp.pressure * 100) / (Rair * trp.temperature)\n\nmls.rename({'density': 'numberDensity'})\nmls['airDensity'] = (mls.pressure * 100) / (Rair * mls.temperature)\n\nmlw.rename({'density': 'numberDensity'})\nmlw['airDensity'] = (mlw.pressure * 100) / (Rair * mlw.temperature)\n\nsas.rename({'density': 'numberDensity'})\nsas['airDensity'] = (sas.pressure * 100) / (Rair * sas.temperature)\n\nsaw.rename({'density': 'numberDensity'})\nsaw['airDensity'] = (saw.pressure * 100) / (Rair * saw.temperature)\n\n\n# Interpolate the standard atmospheres to a common grid in meters with heights every 100 meters\ntrp.index = trp.altitude*1000\ntrp = trp.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nmls.index = mls.altitude*1000\nmls = mls.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nmlw.index = mlw.altitude*1000\nmlw = mlw.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nsas.index = sas.altitude*1000\nsas = sas.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nsaw.index = saw.altitude*1000\nsaw = saw.reindex(np.arange(0,60001,100)).interpolate(method='linear')"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#choose-the-standard-atmosphere",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#choose-the-standard-atmosphere",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "Standard Atmosphere\nstdatm_name\n\n\n\n\nTropical\n‘trp’\n\n\nMid-Latitude Summer\n‘mls’\n\n\nMid-Latitude Winter\n‘mlw’\n\n\nSub-Arctic Summer\n‘sas’\n\n\nSub-Arctic Winter\n‘saw’\n\n\n\n\n# Change this variable to choose the model atmosphere\n# !! NOTE that the single quotation marks are important !!\n\nstdatm_name = 'mlw'\n\nif 'trp' in stdatm_name:\n    stdatm = trp\nelif 'mls' in stdatm_name:\n    stdatm = mls\nelif 'mlw' in stdatm_name:\n    stdatm = mlw\nelif 'sas' in stdatm_name:\n    stdatm = sas\nelif 'saw' in stdatm_name:\n    stdatm = saw\nelse:\n    print(\"ERROR: This standard atmosphere is NOT RECOGNIZED. Try setting stdatm_name again!!\")"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#set-the-atmospheric-co2-concentration-in-ppmv",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#set-the-atmospheric-co2-concentration-in-ppmv",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "# Set CO2 in all Standard Atmospheres.\n#co2 = 330.   # ppmv; approximate concentration in 1971\n#co2 = 419.   # ppmv; current concentration in 2023\n#co2 = 280.   # ppmv; pre-industrial concentration\nco2 = 560.   # ppmv; doubled CO2 concentration (from pre-industrial)\n\ntrp['co2'] = mls['co2'] = mlw['co2'] = sas['co2'] = saw['co2'] = co2\n\n\n\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(20,10), nrows=1, ncols=3, sharey=True)\n\n# Pressure\ntrp.plot(ax=ax1, x='pressure', y='altitude')\nmls.plot(ax=ax1, x='pressure', y='altitude')\nmlw.plot(ax=ax1, x='pressure', y='altitude')\nsas.plot(ax=ax1, x='pressure', y='altitude')\nsaw.plot(ax=ax1, x='pressure', y='altitude')\nax1.grid()\nax1.set_xlabel('Pressure (mb)');\nax1.set_ylabel('Altitude (km)');\nax1.set_title('Atmospheric Pressure for Standard Atmospheres');\nax1.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n# Temperature\ntrp.plot(ax=ax2, x='temperature', y='altitude')\nmls.plot(ax=ax2, x='temperature', y='altitude')\nmlw.plot(ax=ax2, x='temperature', y='altitude')\nsas.plot(ax=ax2, x='temperature', y='altitude')\nsaw.plot(ax=ax2, x='temperature', y='altitude')\nax2.grid()\nax2.set_xlabel('Temperature (K)');\nax2.set_ylabel('Altitude (km)');\nax2.set_title('Temperature Profiles for Standard Atmospheres');\nax2.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n#O3\ntrp.plot(ax=ax3, x='airDensity', y='altitude')\nmls.plot(ax=ax3, x='airDensity', y='altitude')\nmlw.plot(ax=ax3, x='airDensity', y='altitude')\nsas.plot(ax=ax3, x='airDensity', y='altitude')\nsaw.plot(ax=ax3, x='airDensity', y='altitude')\nax3.grid()\nax3.set_xlabel('Density (kg m-3)');\nax3.set_ylabel('Altitude (km)');\nax3.set_title('Density of Air for Standard Atmospheres');\nax3.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n\n\n\n\n\n\n\n\n\n\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(20,10), nrows=1, ncols=3, sharey=True)\n\n# H2O\ntrp.plot(ax=ax1, x='h2o', y='altitude')\nmls.plot(ax=ax1, x='h2o', y='altitude')\nmlw.plot(ax=ax1, x='h2o', y='altitude')\nsas.plot(ax=ax1, x='h2o', y='altitude')\nsaw.plot(ax=ax1, x='h2o', y='altitude')\nax1.grid()\nax1.set_xlabel('Water Vapor (ppmv)');\nax1.set_ylabel('Altitude (km)');\nax1.set_title('Water Vapor concentration for Standard Atmospheres');\nax1.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n# CO2\ntrp.plot(ax=ax2, x='co2', y='altitude')\nmls.plot(ax=ax2, x='co2', y='altitude')\nmlw.plot(ax=ax2, x='co2', y='altitude')\nsas.plot(ax=ax2, x='co2', y='altitude')\nsaw.plot(ax=ax2, x='co2', y='altitude')\nax2.grid()\nax2.set_xlabel('Carbon Dioxide (ppmv)');\nax2.set_ylabel('Altitude (km)');\nax2.set_title('Carbon Dioxide concentration for Standard Atmospheres');\nax2.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n#O3\ntrp.plot(ax=ax3, x='o3', y='altitude')\nmls.plot(ax=ax3, x='o3', y='altitude')\nmlw.plot(ax=ax3, x='o3', y='altitude')\nsas.plot(ax=ax3, x='o3', y='altitude')\nsaw.plot(ax=ax3, x='o3', y='altitude')\nax3.grid()\nax3.set_xlabel('Ozone (ppmv)');\nax3.set_ylabel('Altitude (km)');\nax3.set_title('Ozone concentration for Standard Atmospheres');\nax3.legend(['TRP','MLS','MLW','SAS','SAW']);"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-optical-depth",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-optical-depth",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "Now that we have values for the air density and the concentrations of the greenhouse gases, it is easy to calculate the optical depth for individual gases.\nWe will use mass absorption coefficients for carbon dioxide at the following wavelengths (from the center of the 15-um CO2 band towards the atmospheric window between 8 and 12.5 um):\n\n\n\n\n\n\n\n\n\nType of Absorption\nWavenumber (\\(cm^{-1}\\))\nWavelength (\\(\\mu\\)m)\n\\(\\kappa_a\\) (\\(m^2 kg^{-1}\\))\n\n\n\n\nVery Strong\n667\n15\n2000\n\n\nVery Strong\n714\n14\n10\n\n\nModerate\n769\n13\n0.1\n\n\nWeak\n833\n12\n0.001\n\n\n\nThese mass absorption coefficients values were approximated from Figure 2 in Pierrehumbert, Physics Today, January 2011.\nSo, the optical depth can now be calculated for each layer of the atmosphere by multiplying the absorption cross sections (\\(\\kappa_a\\)) by the air density, and then by the thickness of the atmospheric layer, as shown in the code below (for the Mid-latitude Winter Standard Atmosphere - MLW).\nDisclaimer: Please note that this calculation of optical depth is for illustrative purposes only, and is over-simplified in the following ways:\n\nIn most cases H2O overlaps the absorption bands of all the other GH gases. (See Figure 2 of Pierrehumbert (2010); blowup of 600-670 cm-1).\nWe are neglecting how the line strengths of absorption lines depend on temperature in the atmosphere (https://hitran.org/docs/definitions-and-units/)\nWe are neglecting how the widths of absorption lines depend on both temperature and pressure (https://hitran.org/docs/definitions-and-units/)\n\nAccurate radiative transfer models of the atmosphere account for all of this issues.\n\nKa_15 = 2000\nKa_14 = 10\nKa_13 = 0.1\nKa_12 = 0.001\n\nrhoCO2 = stdatm.airDensity[:-1] * stdatm.co2[:-1]/1e6     # Convert from ppmv to percent fraction\ndz   = np.diff(stdatm.altitude) * 1000                 # Calculate the height of each layer by differencing levels; meters\n\n# Calculate and plot the optical depth at 14.6 um for CO2 for the MLW Standard Atmosphere.\nstdatm['od_15'] = Ka_15 * rhoCO2 * dz\nstdatm['od_14'] = Ka_14 * rhoCO2 * dz\nstdatm['od_13'] = Ka_13 * rhoCO2 * dz\nstdatm['od_12'] = Ka_12 * rhoCO2 * dz\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='od_15', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_14', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_13', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_12', y='altitude', logx=True, logy=True)\nax.grid()\nax.set_xlabel('Optical Depth');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Optical Depths for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-transmission",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-transmission",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "stdatm['T_15'] = np.exp(-stdatm.od_15) * 100\nstdatm['T_14'] = np.exp(-stdatm.od_14) * 100\nstdatm['T_13'] = np.exp(-stdatm.od_13) * 100\nstdatm['T_12'] = np.exp(-stdatm.od_12) * 100\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='T_15', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_14', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_13', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_12', y='altitude', logx=True)\nax.axis([0.1, 120, 0, 60])\nax.grid()\nax.set_xlabel('Transmission');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Transmission for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\n\nThe above figure shows the transmission as a function of altitude in the atmosphere. But how do we calculate the transmission through the entire atmosphere?\nThere are two ways to do this:\n\nMultiply all the transmission from each layer together, or\n\n\\[ T_{total} = e^{- \\tau_1} e^{- \\tau_2} e^{- \\tau_3} ... \\]\n\nOr (because of the properties of exponents) one can just add up all the optical depths for each layer and take the exponential of that sum\n\n\\[ T_{total} = e^{- \\tau_1} e^{- \\tau_2} e^{- \\tau_3} ... = e^{- (\\tau_1 +  \\tau_2 + \\tau_3 ...)} \\]\nOption 2 is much easier for us here; see the code below.\n\n# Calculate total transmission in the atmosphere by summing all optical depths\nTtotal_15 = np.exp(-stdatm.od_15.sum())\nTtotal_14 = np.exp(-stdatm.od_14.sum())\nTtotal_13 = np.exp(-stdatm.od_13.sum())\nTtotal_12 = np.exp(-stdatm.od_12.sum())\n\n# Print results\nprint(f'Total transmission in atmosphere (%) at 15 um = {Ttotal_15*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 14 um = {Ttotal_14*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 13 um = {Ttotal_13*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 12 um = {Ttotal_12*100:.2f} %')\n\nTotal transmission in atmosphere (%) at 15 um = 0.00 %\nTotal transmission in atmosphere (%) at 14 um = 0.00 %\nTotal transmission in atmosphere (%) at 13 um = 55.59 %\nTotal transmission in atmosphere (%) at 12 um = 99.41 %"
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-absorption-and-emissivity",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-absorption-and-emissivity",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "An important property of thermal radiation is given by Kirchhoff’s Law. It states that\n\"For an arbitrary body emitting and absorbing thermal radiation in thermodynamic equilibrium, the emissivity is equal to the absorptivity.\"\nWe don’t have time to discuss this in CE401, but it states that a good emitter (high emissivity object) is an equally good absorber.\nThis holds true for the atmosphere as well. So, if we calculate the absorption of the atmosphere as\n\\[ Absorption = 1 - Transmission \\]\nthen also\n\\[ Emissivity = 1 - Transmission \\]\n\n\n\nstdatm['A_15'] = (1. - np.exp(-stdatm.od_15)) * 100        # Convert from fraction to percent\nstdatm['A_14'] = (1. - np.exp(-stdatm.od_14)) * 100\nstdatm['A_13'] = (1. - np.exp(-stdatm.od_13)) * 100\nstdatm['A_12'] = (1. - np.exp(-stdatm.od_12)) * 100\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='A_15', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_14', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_13', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_12', y='altitude', logx=True)\nax.grid()\nax.set_xlabel('Absorption');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Absorption for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\n\n\n# Print results\nprint(f'Total absorption in atmosphere (%) at 15 um = {(1 - Ttotal_15)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 14 um = {(1 - Ttotal_14)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 13 um = {(1 - Ttotal_13)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 12 um = {(1 - Ttotal_12)*100:.2f} %')\n\nTotal absorption in atmosphere (%) at 15 um = 100.00 %\nTotal absorption in atmosphere (%) at 14 um = 100.00 %\nTotal absorption in atmosphere (%) at 13 um = 44.41 %\nTotal absorption in atmosphere (%) at 12 um = 0.59 %"
  }
]