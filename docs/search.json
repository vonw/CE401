[
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "",
    "text": "© Von P. Walden, Washington State University\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#definition-of-the-optical-depth",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#definition-of-the-optical-depth",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "Definition of the Optical Depth",
    "text": "Definition of the Optical Depth\nTo calculate the infrared absorption by the atmosphere, we must calculate the optical depth. The optical depth is related to the transmission of radiation through “optical media”, such as an absorbing gas or an absorbing liquid. Beer’s Law gives us\n\\[ I(\\lambda) = I_o(\\lambda) e^{-\\tau} \\]\nThis can be rewritten as\n\\[ Transmission = \\frac{I(\\lambda)}{I_o(\\lambda)} = e^{-\\tau} \\]\nThen one can solve for the optical depth \\(\\tau\\) as\n\\[ \\tau = -ln \\Big[ \\frac{I(\\lambda)}{I_o(\\lambda)} \\Big] \\]\nIn general, the optical depth is:\n\\[ \\tau = \\int_{z_1}^{z_2} \\beta_{\\lambda} dz = \\int_{z_1}^{z_2} \\kappa_{\\lambda} \\rho (z) dz = \\int_{z_1}^{z_2} \\sigma_{\\lambda} n(z) dz \\]\nwhere - \\(\\beta\\) is the volume absorption coefficient, - \\(\\kappa\\) is the mass absorption coefficient, - \\(\\sigma\\) is the absorption cross section,\nwhich all depend on wavelength, \\(\\lambda\\).\n\\(\\rho(z)\\) and n(z) are the air density and the number density of the absorbing gas. z is distance along the absorbing path from \\(z_1\\) to \\(z_2\\).\nIf one conducts an experiment of Beer’s Law in the lab using a tube filled with an absorbing gas (like H2O or CO2), this equation reduces to:\n\\[ \\tau = \\beta (z_2 - z_1) = \\kappa_{\\lambda} \\rho (z_2 - z_1) = \\sigma_{\\lambda} N (z_2 - z_1) \\]\nNote that this is how scientists (100 or so years ago) determined how different gases absorbed infrared radiation at different wavelengths, by measuring the transmission of radiation through the gas, calculating the optical depth, then solving for either \\(\\beta_{\\lambda}\\), \\(\\kappa_{\\lambda}\\), or \\(\\sigma_{\\lambda}\\).\n\nOptical Depth in the Atmosphere\nTo determine the optical depth in the atmosphere, one must use the general equation above, because the number of molecules of absorbing gas changes with height in the atmosphere. Carbon dioxide is “uniformly mixed” in the atmosphere, meaning that its concentration relative to other gases does not change with height. However, the actual number of CO2 molecules decreases exponentially with height in the atmosphere because the density (and pressure) of the air decreases in this manner. Most of the water vapor in the atmosphere is contained only in the troposphere in the lowest 7 or 8 km. Therefore, one must integrate through the atmosphere to determine the optical depth using:\n\\[ \\tau = \\int_{z_1}^{z_2} \\kappa_{\\lambda} \\rho (z) dz \\]\nHere we have chosen to use the specific formula of the optical depth that contains the mass absorption coefficient, because Figure 2 of Pierrehumbert (2010) gives values of \\(\\kappa\\) for both H2O and CO2.",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#the-mcclatchey-standard-atmospheres",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#the-mcclatchey-standard-atmospheres",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "The McClatchey Standard Atmospheres",
    "text": "The McClatchey Standard Atmospheres\nWe’re lucky because McClatchey et al (1972) [in Optical Properties of the Atmosphere (Third Edition)] created a series of “standard atmospheres” for different locations and seasons on Earth that give us n(z) as a function of altitude (z) in the atmosphere. The McClatchey Standard Atmospheres are for:\n\nTropics (TRP)\nMid-latitude Summer (MLS)\nMid-latitude Winter (MLW)\nSub-Arctic Summer (SAS)\nSub-Arctic Winter (SAW)\n\n\n# Read in raw data files\ncolumns = ['layer', 'altitude', 'pressure', 'temperature', 'dew_point', 'density', 'h2o', 'co2', 'o3', 'n2o', 'co', 'ch4', 'o2']\ntrp = pd.read_table('trp.dat', sep='\\s+', names=columns)\nmls = pd.read_table('mls.dat', sep='\\s+', names=columns)\nmlw = pd.read_table('mlw.dat', sep='\\s+', names=columns)\nsas = pd.read_table('sas.dat', sep='\\s+', names=columns)\nsaw = pd.read_table('saw.dat', sep='\\s+', names=columns)\n\n\nRair = 287.058        # J kg-1 K-1\n# Calculate air density\ntrp.rename({'density': 'numberDensity'})\ntrp['airDensity'] = (trp.pressure * 100) / (Rair * trp.temperature)\n\nmls.rename({'density': 'numberDensity'})\nmls['airDensity'] = (mls.pressure * 100) / (Rair * mls.temperature)\n\nmlw.rename({'density': 'numberDensity'})\nmlw['airDensity'] = (mlw.pressure * 100) / (Rair * mlw.temperature)\n\nsas.rename({'density': 'numberDensity'})\nsas['airDensity'] = (sas.pressure * 100) / (Rair * sas.temperature)\n\nsaw.rename({'density': 'numberDensity'})\nsaw['airDensity'] = (saw.pressure * 100) / (Rair * saw.temperature)\n\n\n# Interpolate the standard atmospheres to a common grid in meters with heights every 100 meters\ntrp.index = trp.altitude*1000\ntrp = trp.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nmls.index = mls.altitude*1000\nmls = mls.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nmlw.index = mlw.altitude*1000\nmlw = mlw.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nsas.index = sas.altitude*1000\nsas = sas.reindex(np.arange(0,60001,100)).interpolate(method='linear')\n\nsaw.index = saw.altitude*1000\nsaw = saw.reindex(np.arange(0,60001,100)).interpolate(method='linear')",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#choose-the-standard-atmosphere",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#choose-the-standard-atmosphere",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "1) Choose the standard atmosphere",
    "text": "1) Choose the standard atmosphere\n\n\n\nStandard Atmosphere\nstdatm_name\n\n\n\n\nTropical\n‘trp’\n\n\nMid-Latitude Summer\n‘mls’\n\n\nMid-Latitude Winter\n‘mlw’\n\n\nSub-Arctic Summer\n‘sas’\n\n\nSub-Arctic Winter\n‘saw’\n\n\n\n\n# Change this variable to choose the model atmosphere\n# !! NOTE that the single quotation marks are important !!\n\nstdatm_name = 'mlw'\n\nif 'trp' in stdatm_name:\n    stdatm = trp\nelif 'mls' in stdatm_name:\n    stdatm = mls\nelif 'mlw' in stdatm_name:\n    stdatm = mlw\nelif 'sas' in stdatm_name:\n    stdatm = sas\nelif 'saw' in stdatm_name:\n    stdatm = saw\nelse:\n    print(\"ERROR: This standard atmosphere is NOT RECOGNIZED. Try setting stdatm_name again!!\")",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#set-the-atmospheric-co2-concentration-in-ppmv",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#set-the-atmospheric-co2-concentration-in-ppmv",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "2) Set the atmospheric CO2 concentration (in ppmv)",
    "text": "2) Set the atmospheric CO2 concentration (in ppmv)\n\n# Set CO2 in all Standard Atmospheres.\n#co2 = 330.   # ppmv; approximate concentration in 1971\n#co2 = 420.   # ppmv; current concentration in 2024\n#co2 = 280.   # ppmv; pre-industrial concentration\nco2 = 560.   # ppmv; doubled CO2 concentration (from pre-industrial)\n\ntrp['co2'] = mls['co2'] = mlw['co2'] = sas['co2'] = saw['co2'] = co2#\n\n\n\nPressure, Temperature, and Air Density in the Standard Atmospheres\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(20,10), nrows=1, ncols=3, sharey=True)\n\n# Pressure\ntrp.plot(ax=ax1, x='pressure', y='altitude')\nmls.plot(ax=ax1, x='pressure', y='altitude')\nmlw.plot(ax=ax1, x='pressure', y='altitude')\nsas.plot(ax=ax1, x='pressure', y='altitude')\nsaw.plot(ax=ax1, x='pressure', y='altitude')\nax1.grid()\nax1.set_xlabel('Pressure (mb)');\nax1.set_ylabel('Altitude (km)');\nax1.set_title('Atmospheric Pressure for Standard Atmospheres');\nax1.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n# Temperature\ntrp.plot(ax=ax2, x='temperature', y='altitude')\nmls.plot(ax=ax2, x='temperature', y='altitude')\nmlw.plot(ax=ax2, x='temperature', y='altitude')\nsas.plot(ax=ax2, x='temperature', y='altitude')\nsaw.plot(ax=ax2, x='temperature', y='altitude')\nax2.grid()\nax2.set_xlabel('Temperature (K)');\nax2.set_ylabel('Altitude (km)');\nax2.set_title('Temperature Profiles for Standard Atmospheres');\nax2.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n#O3\ntrp.plot(ax=ax3, x='airDensity', y='altitude')\nmls.plot(ax=ax3, x='airDensity', y='altitude')\nmlw.plot(ax=ax3, x='airDensity', y='altitude')\nsas.plot(ax=ax3, x='airDensity', y='altitude')\nsaw.plot(ax=ax3, x='airDensity', y='altitude')\nax3.grid()\nax3.set_xlabel('Density (kg m-3)');\nax3.set_ylabel('Altitude (km)');\nax3.set_title('Density of Air for Standard Atmospheres');\nax3.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n\n\n\n\n\n\n\n\n\nPrimary Greenhouse Gas Concentrations in Standard Atmospheres\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(20,10), nrows=1, ncols=3, sharey=True)\n\n# H2O\ntrp.plot(ax=ax1, x='h2o', y='altitude')\nmls.plot(ax=ax1, x='h2o', y='altitude')\nmlw.plot(ax=ax1, x='h2o', y='altitude')\nsas.plot(ax=ax1, x='h2o', y='altitude')\nsaw.plot(ax=ax1, x='h2o', y='altitude')\nax1.grid()\nax1.set_xlabel('Water Vapor (ppmv)');\nax1.set_ylabel('Altitude (km)');\nax1.set_title('Water Vapor concentration for Standard Atmospheres');\nax1.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n# CO2\ntrp.plot(ax=ax2, x='co2', y='altitude')\nmls.plot(ax=ax2, x='co2', y='altitude')\nmlw.plot(ax=ax2, x='co2', y='altitude')\nsas.plot(ax=ax2, x='co2', y='altitude')\nsaw.plot(ax=ax2, x='co2', y='altitude')\nax2.grid()\nax2.set_xlabel('Carbon Dioxide (ppmv)');\nax2.set_ylabel('Altitude (km)');\nax2.set_title('Carbon Dioxide concentration for Standard Atmospheres');\nax2.legend(['TRP','MLS','MLW','SAS','SAW']);\n\n#O3\ntrp.plot(ax=ax3, x='o3', y='altitude')\nmls.plot(ax=ax3, x='o3', y='altitude')\nmlw.plot(ax=ax3, x='o3', y='altitude')\nsas.plot(ax=ax3, x='o3', y='altitude')\nsaw.plot(ax=ax3, x='o3', y='altitude')\nax3.grid()\nax3.set_xlabel('Ozone (ppmv)');\nax3.set_ylabel('Altitude (km)');\nax3.set_title('Ozone concentration for Standard Atmospheres');\nax3.legend(['TRP','MLS','MLW','SAS','SAW']);",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-optical-depth",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-optical-depth",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "Calculating Optical Depth",
    "text": "Calculating Optical Depth\nNow that we have values for the air density and the concentrations of the greenhouse gases, it is easy to calculate the optical depth for individual gases.\nWe will use mass absorption coefficients for carbon dioxide at the following wavelengths (from the center of the 15-um CO2 band towards the atmospheric window between 8 and 12.5 um):\n\n\n\n\n\n\n\n\n\nType of Absorption\nWavenumber (\\(cm^{-1}\\))\nWavelength (\\(\\mu\\)m)\n\\(\\kappa_a\\) (\\(m^2 kg^{-1}\\))\n\n\n\n\nVery Strong\n667\n15\n2000\n\n\nVery Strong\n714\n14\n10\n\n\nModerate\n769\n13\n0.1\n\n\nWeak\n833\n12\n0.001\n\n\n\nThese mass absorption coefficients values were approximated from Figure 2 in Pierrehumbert, Physics Today, January 2011.\nSo, the optical depth can now be calculated for each layer of the atmosphere by multiplying the absorption cross sections (\\(\\kappa_a\\)) by the air density, and then by the thickness of the atmospheric layer, as shown in the code below (for the Mid-latitude Winter Standard Atmosphere - MLW).\nDisclaimer: Please note that this calculation of optical depth is for illustrative purposes only, and is over-simplified in the following ways:\n\nIn most cases H2O overlaps the absorption bands of all the other GH gases. (See Figure 2 of Pierrehumbert (2010); blowup of 600-670 cm-1).\nWe are neglecting how the line strengths of absorption lines depend on temperature in the atmosphere (https://hitran.org/docs/definitions-and-units/)\nWe are neglecting how the widths of absorption lines depend on both temperature and pressure (https://hitran.org/docs/definitions-and-units/)\n\nAccurate radiative transfer models of the atmosphere account for all of this issues.\n\nKa_15 = 2000\nKa_14 = 10\nKa_13 = 0.1\nKa_12 = 0.001\n\nrhoCO2 = stdatm.airDensity[:-1] * stdatm.co2[:-1]/1e6     # Convert from ppmv to percent fraction\ndz   = np.diff(stdatm.altitude) * 1000                 # Calculate the height of each layer by differencing levels; meters\n\n# Calculate and plot the optical depth at 14.6 um for CO2 for the MLW Standard Atmosphere.\nstdatm['od_15'] = Ka_15 * rhoCO2 * dz\nstdatm['od_14'] = Ka_14 * rhoCO2 * dz\nstdatm['od_13'] = Ka_13 * rhoCO2 * dz\nstdatm['od_12'] = Ka_12 * rhoCO2 * dz\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='od_15', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_14', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_13', y='altitude', logx=True, logy=True)\nstdatm.plot(ax=ax, x='od_12', y='altitude', logx=True, logy=True)\nax.grid()\nax.set_xlabel('Optical Depth');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Optical Depths for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-transmission",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-transmission",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "Calculating Atmospheric Transmission",
    "text": "Calculating Atmospheric Transmission\n\nAs a function of altitude\n\nstdatm['T_15'] = np.exp(-stdatm.od_15) * 100\nstdatm['T_14'] = np.exp(-stdatm.od_14) * 100\nstdatm['T_13'] = np.exp(-stdatm.od_13) * 100\nstdatm['T_12'] = np.exp(-stdatm.od_12) * 100\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='T_15', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_14', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_13', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='T_12', y='altitude', logx=True)\nax.axis([0.1, 120, 0, 60])\nax.grid()\nax.set_xlabel('Transmission');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Transmission for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\nTransmission through the entire atmosphere\nThe above figure shows the transmission as a function of altitude in the atmosphere. But how do we calculate the transmission through the entire atmosphere?\nThere are two ways to do this:\n\nMultiply all the transmission from each layer together, or\n\n\\[ T_{total} = e^{- \\tau_1} e^{- \\tau_2} e^{- \\tau_3} ... \\]\n\nOr (because of the properties of exponents) one can just add up all the optical depths for each layer and take the exponential of that sum\n\n\\[ T_{total} = e^{- \\tau_1} e^{- \\tau_2} e^{- \\tau_3} ... = e^{- (\\tau_1 +  \\tau_2 + \\tau_3 ...)} \\]\nOption 2 is much easier for us here; see the code below.\n\n# Calculate total transmission in the atmosphere by summing all optical depths\nTtotal_15 = np.exp(-stdatm.od_15.sum())\nTtotal_14 = np.exp(-stdatm.od_14.sum())\nTtotal_13 = np.exp(-stdatm.od_13.sum())\nTtotal_12 = np.exp(-stdatm.od_12.sum())\n\n# Print results\nprint(f'Total transmission in atmosphere (%) at 15 um = {Ttotal_15*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 14 um = {Ttotal_14*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 13 um = {Ttotal_13*100:.2f} %')\nprint(f'Total transmission in atmosphere (%) at 12 um = {Ttotal_12*100:.2f} %')\n\nTotal transmission in atmosphere (%) at 15 um = 0.00 %\nTotal transmission in atmosphere (%) at 14 um = 0.00 %\nTotal transmission in atmosphere (%) at 13 um = 55.59 %\nTotal transmission in atmosphere (%) at 12 um = 99.41 %",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-absorption-and-emissivity",
    "href": "chapter4/InfraredAbsorptionByTheAtmosphere.html#calculating-atmospheric-absorption-and-emissivity",
    "title": "Infrared Absorption by the Atmosphere",
    "section": "Calculating Atmospheric Absorption and Emissivity",
    "text": "Calculating Atmospheric Absorption and Emissivity\nAn important property of thermal radiation is given by Kirchhoff’s Law. It states that\n\"For an arbitrary body emitting and absorbing thermal radiation in thermodynamic equilibrium, the emissivity is equal to the absorptivity.\"\nWe don’t have time to discuss this in CE401, but it states that a good emitter (high emissivity object) is an equally good absorber.\nThis holds true for the atmosphere as well. So, if we calculate the absorption of the atmosphere as\n\\[ Absorption = 1 - Transmission \\]\nthen also\n\\[ Emissivity = 1 - Transmission \\]\n\nAs a function of altitude\n\nstdatm['A_15'] = (1. - np.exp(-stdatm.od_15)) * 100        # Convert from fraction to percent\nstdatm['A_14'] = (1. - np.exp(-stdatm.od_14)) * 100\nstdatm['A_13'] = (1. - np.exp(-stdatm.od_13)) * 100\nstdatm['A_12'] = (1. - np.exp(-stdatm.od_12)) * 100\n\n\nfig, ax = plt.subplots(figsize=(10,10))\n\nstdatm.plot(ax=ax, x='A_15', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_14', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_13', y='altitude', logx=True)\nstdatm.plot(ax=ax, x='A_12', y='altitude', logx=True)\nax.grid()\nax.set_xlabel('Absorption');\nax.set_ylabel('Altitude (km)');\nax.set_title('Infrared Absorption for CO2 in ' + stdatm_name + 'Standard Atmospheres');\nax.legend(['15 um','14 um','13 um','12 um']);\n\n\n\n\n\n\n\n\n\n\nAbsorption by the entire atmosphere\n\n# Print results\nprint(f'Total absorption in atmosphere (%) at 15 um = {(1 - Ttotal_15)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 14 um = {(1 - Ttotal_14)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 13 um = {(1 - Ttotal_13)*100:.2f} %')\nprint(f'Total absorption in atmosphere (%) at 12 um = {(1 - Ttotal_12)*100:.2f} %')\n\nTotal absorption in atmosphere (%) at 15 um = 100.00 %\nTotal absorption in atmosphere (%) at 14 um = 100.00 %\nTotal absorption in atmosphere (%) at 13 um = 29.25 %\nTotal absorption in atmosphere (%) at 12 um = 0.35 %",
    "crumbs": [
      "Chapter 4",
      "Infrared Absorption by the Atmosphere"
    ]
  },
  {
    "objectID": "chapter4/SolarConstant.html",
    "href": "chapter4/SolarConstant.html",
    "title": "Calculation of the Solar Constant",
    "section": "",
    "text": "© Von P. Walden, Washington State University",
    "crumbs": [
      "Chapter 4",
      "Calculation of the Solar Constant"
    ]
  },
  {
    "objectID": "chapter4/SolarConstant.html#useful-links",
    "href": "chapter4/SolarConstant.html#useful-links",
    "title": "Calculation of the Solar Constant",
    "section": "Useful links",
    "text": "Useful links\n\nInformation on the Solar “Constant”\n\n\nInformation on Earth’s orbit\n\nimport numpy as np\nimport pandas as pd\n\n\n\na) Calculate the flux emitted by the Sun in W m-2 using the Stefan-Boltzmann Law.\n\nTsun = 5772                   # K; chosen to yield S = 1361 W m-2\nE    = 5.67e-8 * Tsun**4        # W m-2\nprint('The flux from the Sun is:',E, 'W m-2')\n\n\n\nb) Calculate the total power emitted by the Sun’s surface.\n\nRs   = 695.7e6                    # meters\nAs   = 4*np.pi*Rs**2                 # m2\nPsun = E * As\nprint('Power emitted by the Sun is:', Psun, 'Watts')\n\n\n\nNow determine the flux (in W m-2) from the Sun, but at the distance of the Earth’s orbit. NOTE that the total power from the Sun is spread over a very large area (in space…)\n\n# Average radius of Earth's orbit around the Sun.\nRes   = 149.6e9                    # meters\n# Surface area of a sphere with radius equal to Re.\nAes   = 4*np.pi*Res**2                # m2\n# Solar Constant\nS     = Psun / Aes\nprint('The Solar Constant for Earth is:', S, 'W m-2')\n\n\n\n\nNow how much power is intercepted by the Earth as the Sun’s rays pass by it.\n\nRe   = 6.4e6                        # meters\nAint = np.pi*Re**2                     # Area intercepted by Earth in m2\nPe   = S * Aint\nprint('The amount of power (in Watts) that is constantly intercepted by Earth is:', Pe, 'Watts')\n\n\n\nConvert this to Terawatts (TW); 1 TW = 1e12 W\n\nprint('The amount of power (in TW) that is constantly intercepted by Earth is:', Pe/1e12, 'TW')",
    "crumbs": [
      "Chapter 4",
      "Calculation of the Solar Constant"
    ]
  },
  {
    "objectID": "chapter4/SolarConstant.html#as-dessler-explains-all-of-human-society-currently-consumes-only-16-tw.-so-we-only-need-to-capture-0.01-of-the-suns-power-to-meet-all-of-our-energy-needs.",
    "href": "chapter4/SolarConstant.html#as-dessler-explains-all-of-human-society-currently-consumes-only-16-tw.-so-we-only-need-to-capture-0.01-of-the-suns-power-to-meet-all-of-our-energy-needs.",
    "title": "Calculation of the Solar Constant",
    "section": "As Dessler explains, all of human society currently consumes only 16 TW. So we only need to capture 0.01% of the Sun’s power to meet all of our energy needs.",
    "text": "As Dessler explains, all of human society currently consumes only 16 TW. So we only need to capture 0.01% of the Sun’s power to meet all of our energy needs.\n\n\na = 0.3                               # Earth's albedo; unitless\nS*(1-a)/4\n\n\nNote that S/4 is equal to 342 W m-2.\n\nS/4",
    "crumbs": [
      "Chapter 4",
      "Calculation of the Solar Constant"
    ]
  },
  {
    "objectID": "chapter4/SolarConstant.html#sensitivity-to-earth-sun-distance",
    "href": "chapter4/SolarConstant.html#sensitivity-to-earth-sun-distance",
    "title": "Calculation of the Solar Constant",
    "section": "Sensitivity to Earth-Sun Distance",
    "text": "Sensitivity to Earth-Sun Distance\n\nSensRes                   = pd.DataFrame({'Earth-Sun Distance': [147.1e9,149.6e9,152.1e9]})\nSensRes['Area']           = 4 * np.pi * SensRes['Earth-Sun Distance']**2\nSensRes['Solar Constant'] = Psun / SensRes['Area']\nSensRes['% difference']   = (SensRes['Solar Constant'] - SensRes['Solar Constant'].iloc[1]) / SensRes['Solar Constant'].iloc[1] * 100\nSensRes",
    "crumbs": [
      "Chapter 4",
      "Calculation of the Solar Constant"
    ]
  },
  {
    "objectID": "chapter4/SolarConstant.html#sensitivity-to-suns-surface-temperature.",
    "href": "chapter4/SolarConstant.html#sensitivity-to-suns-surface-temperature.",
    "title": "Calculation of the Solar Constant",
    "section": "Sensitivity to Sun’s surface temperature.",
    "text": "Sensitivity to Sun’s surface temperature.\n\nNote that the solar constant varies by about 0.1% (1.3 W m-2) during the 11-year solar cycle, from about 1361 to 1362.3 W m-2. http://acrim.com/TSI%20Monitoring.htm\n\nTsun = np.array([5772, 5773.5])   # K; chosen to yield S = 1361 W m-2\nE    = 5.67e-8 * Tsun**4        # W m-2\nRs   = 695.7e6                  # meters\nAs   = 4*np.pi*Rs**2               # m2\nPsun = E * As\n# Average radius of Earth's orbit around the Sun.\nRes   = 149.6e9                 # meters\n# Surface area of a sphere with radius equal to Re.\nAes   = 4*np.pi*Res**2             # m2\n# Solar Constant\nS     = Psun / Aes\n\nSensTsun = pd.DataFrame({'Temperature of Sun':   Tsun,\n                         'Power Emitted by Sun': Psun,\n                         'Solar Constant':       S,\n                         '% difference': (S-S[0])/S[1]*100})\nSensTsun[['Temperature of Sun', 'Power Emitted by Sun', 'Solar Constant', '% difference']]",
    "crumbs": [
      "Chapter 4",
      "Calculation of the Solar Constant"
    ]
  },
  {
    "objectID": "chapter4/EquilibriumTemperatureOfEarth.html",
    "href": "chapter4/EquilibriumTemperatureOfEarth.html",
    "title": "Equilibrium Temperature of Earth",
    "section": "",
    "text": "Calculation of the Equilibrium Temperature of Earth\n\nEquation 4.3(b) in Dessler.\n\nS = 1360                  # W m-2\na = 0.3                   # unitless\nTequilibrium = (S*(1-a)/(4*5.67e-8))**(1/4)\n\n\nprint('The Equilibrium Temperature of Earth is:', Tequilibrium, 'K')"
  },
  {
    "objectID": "chapter3/RadiationInSpectralBands.html",
    "href": "chapter3/RadiationInSpectralBands.html",
    "title": "Percent Radiation in a Spectral Band",
    "section": "",
    "text": "Calculate Percentage of Radiation in Spectral Bands\n© Von P. Walden, Washington State University\n\nimport numpy as np\nimport xarray as xr\n\n\nFor a given temperature T, calculate the proportion of radiation emitted in various spectral bands (UV, visible, near-infrared, and infrared).\n\n# Temperature of the object\nT  = 5700.                                 # K\n#T  = 3300.                                 # K\nT  = 289.                                  # K\n\n\n# Calculate the Planck radiation distribution between 0 and 50 microns\nc  = 2.998e8                              # m s-1\nh  = 6.626e-34                            # m2 kg s-1\nkB = 1.381e-23                            # m2 kg s-2 K-1\ndl = 0.01                                 # meters\nl  = np.arange(dl,50,dl) * 1e-6           # meters\nB  = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux  = np.pi * B      # W m-2 um-1\n\n# Convert spectralFlux to an Xarray data array\nspectralFlux = xr.DataArray(spectralFlux, coords={'wavelength': l*1e6}, dims=['wavelength'])\n\n# Sum the radiation in uv, vis, nir and ir spectral bands:\n#     UV            = 0   to 0.3 microns\n#     visible       = 0.3 to 0.7 microns\n#     near infrared = 0.7 to 4 microns\n#     infrared      = 4   to 50 microns\nuv  = spectralFlux.sel(wavelength=slice(0,0.3)).sum()*dl\nvis = spectralFlux.sel(wavelength=slice(0.3,0.7)).sum()*dl\nnir = spectralFlux.sel(wavelength=slice(0.7,4)).sum()*dl\nir  = spectralFlux.sel(wavelength=slice(4,50)).sum()*dl\n\n# Calculate the percent contribution in each band\nFlux  = spectralFlux.sum()*dl                           # Total flux in W m-2; Should be nearly equal to sigma * T^4 !!\np_uv  = uv / Flux * 100\np_vis = vis / Flux * 100\np_nir = nir / Flux * 100\np_ir  = ir / Flux * 100\n\n\n#%% Sum all the spectral bands; should be close to 100% !!\nprint('Percent UV:            ', p_uv.values)\nprint('Percent visible:       ', p_vis.values)\nprint('Percent near infrared: ', p_nir.values)\nprint('Percent infrared:      ', p_ir.values)\n\nprint('Total percent:         ', p_uv.values + p_vis.values + p_nir.values + p_ir.values)\n\n\nprint(Flux)\n\n\n5.67e-8*(289**4)",
    "crumbs": [
      "Chapter 3",
      "Percent Radiation in a Spectral Band"
    ]
  },
  {
    "objectID": "chapter3/PlancksLaw.html",
    "href": "chapter3/PlancksLaw.html",
    "title": "Planck’s Law",
    "section": "",
    "text": "Calculate Planck curves as a function of wavelength and temperature\n© Von P. Walden, Washington State University\n\n%matplotlib inline\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nDessler, Figure 3.2a\n\nc  = 2.998e8                              # m s-1\nh  = 6.626e-34                            # m2 kg s-1\nkB = 1.381e-23                            # m2 kg s-2 K-1\nl  = np.arange(0.25,20,0.25) * 1e-6       # meters\nT  = 300.                                 # K\nB  = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux  = np.pi * B\n\n\nplt.plot(l/1e-6,spectralFlux)\nplt.xlabel('Wavelength, microns');\nplt.ylabel('Spectral Flux, W m-2 um-1');\nplt.text(17.5,30,'300 K');\n\n\nl_max = l[np.where(spectralFlux==spectralFlux.max())]\nprint(l_max)\n\n\nprint(f\"Wiens Law gives wavelength of maximum flux at: {(2898/T):4.2f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")\n\n\n\nDessler, Figure 3.2b\n\nl = np.arange(0.25,12,0.05) * 1e-6      # meters\nT = 1600.                               # K\nB = 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\nspectralFlux = pi * B                   # W m-2 um-1\n\n\nplt.plot(l/1e-6,spectralFlux)\nplt.xlabel('Wavelength, microns');\nplt.ylabel('Spectral Flux, W m-2 um-1');\nplt.text(10,120000,'1600 K');\n\n\nprint(f\"Wiens law gives wavelength of maximum flux at: {(2898/T):3.1f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")\n\n\n\nDessler, Figure 3.2c\n\nl  = np.arange(0.01,3.5,0.01) * 1e-6      # meters\nT  = 6000.                                # K\nB  = pi * 2*h*c**2 / (l**5 * (np.exp((h*c) / (l *kB * T)) - 1.)) * 1e-6      # W m-2 um-1\n\n\nplt.plot(l/1e-6,B)\nplt.xlabel('Wavelength, microns');\nplt.ylabel('Flux, W m-2 um-1');\nplt.text(2.8,90e6,'6000 K');\n\n\nprint(f\"Wiens law gives wavelength of maximum flux at: {(2898/T):3.1f} um.\")\n\n\nprint(f\"The Stefan-Boltzmann Law gives the total flux for this object as: {(5.67e-8*T**4):4.0f} W m-2.\")",
    "crumbs": [
      "Chapter 3",
      "Planck's Law"
    ]
  },
  {
    "objectID": "chapter2/plotBerkeleyEarth.html",
    "href": "chapter2/plotBerkeleyEarth.html",
    "title": "Plot Berkeley Earth",
    "section": "",
    "text": "Plot global temperature anomalies from Berkeley Earth\n© Von P. Walden, Washington State University\nThe data used in this notebook are from Berkeley Earth: Land_and_Ocean_LatLong1.nc\n\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport pandas as pd\nimport xarray as xr\n\n\nWorking from your local computer\nIf you are running this notebook from your local computer, you will need to:\n\nDownload a large (400 MB) data file (Land_and_Ocean_LatLong1.nc) from Canvas.\nEdit the code cell below by replacing ‘../Land_and_Ocean_LatLong1.nc’ with the pathname to the data file on your local hard drive.\nNOTE that if you have a PC laptop that runs Windows (as opposed to a Mac or a Linux computer), the syntax of your filename is different. In particular, PCs use a backward slash instead of a forward slash. For Python to recognize the backward slash, one must actually use two backslashes together. So copy the location of the Land_and_Ocean_LatLong1.nc file, then make sure to use double backslashes. An example is given in the code cell below.\n\n\n# ....For Windows PC\n#be = xr.open_dataset('C:\\\\Users\\\\vonw\\\\Land_and_Ocean_LatLong1.nc')\n# ....For Mac or Linux\n#be = xr.open_dataset('../../Land_and_Ocean_LatLong1.nc')\nbe = xr.open_dataset('/Users/vonw/Downloads/Land_and_Ocean_LatLong1.nc')\nbe\n\n\n\nPlot geographic distribution of 1951-1980 climatology\n\n# Select a particular month to view\nmonth = 'Jan'\n\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nfig = plt.figure(figsize=(20,10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\nbe.climatology[months.index(month)].plot(ax=ax)\nplt.title('Climatology (1951-1980) for ' + month);\n\n\n\nPlot geographic distribution of temperature anomalies for given year and month\n\n# Select a particular year and month to view\nyear = 1900\nmonth = 'Jan'\n\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nfig = plt.figure(figsize=(20,10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\n(be.temperature[months.index(month)+((year-1850)*12)]).plot(ax=ax, clim=[-10, 10])\nplt.title('Temperature Anomalies for ' + month + ' ' + str(year));\n\n\n\nPlot geographic distribution of actual temperatures for given year and month\n\n# Select a particular year and month to view\nyear = 2023\nmonth = 'Jan'\n\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\nfig = plt.figure(figsize=(20,10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\n(be.temperature[months.index(month)+((year-1850)*12)] + be.climatology[months.index(month)]).plot(ax=ax, clim=[-10, 10])\nplt.title('Temperatures for ' + month + ' ' + str(year));\n\n\n\nCalculate global annual temperature anomalies\n\n# Select a particular year and month to view\n# !! Depending on how many years you choose to analyze, this COULD TAKE TENS OF SECONDS to complete.\nbeginning_year = 1850\nending_year = 2023\n\nmonths = pd.date_range(start=str(beginning_year), end=str(ending_year+1), freq='ME')\n\ndata = []\nfor month in months:\n    #print(month.month)\n    data.append(be.temperature[month.month+((month.year-1850)*12)].mean())\n\nTanomalies = xr.DataArray(data, coords={'month': months})\n\nfig = plt.figure(figsize=(20,10))\nTanomalies.plot()\nplt.grid()\nplt.xlabel('Month');\nplt.ylabel('Temperature anomaly (C)');\nplt.title('Global monthly temperature anomaly between ' + str(beginning_year) + ' and ' + str(ending_year));\n\n\n\nCalculate longitudinally-averaged temperature anomalies\n\n# Select the latitude range to average over\nbeginning_latitude = -5\nending_latitude = 5\n\n# Select a particular year and month to view\n# !! Depending on how many years you choose to analyze, this COULD TAKE TENS OF SECONDS to complete.\nbeginning_year = 1950\nending_year = 2023\n\nmonths = pd.date_range(start=str(beginning_year), end=str(ending_year+1), freq='ME')\n\ndata = []\nfor month in months:\n    #print(month.month)\n    data.append(be.temperature[month.month+((month.year-1850)*12)].sel(latitude=slice(beginning_latitude, ending_latitude)).mean())\n\nTanomalies = xr.DataArray(data, coords={'month': months})\n\nfig = plt.figure(figsize=(20,10))\nTanomalies.plot()\nplt.grid()\nplt.xlabel('Month');\nplt.ylabel('Temperature anomaly (C)');\nplt.title('Equatorial temperature anomaly between ' + str(beginning_year) + ' and ' + str(ending_year));",
    "crumbs": [
      "Chapter 2",
      "Plot Berkeley Earth"
    ]
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html",
    "href": "chapter10/ExponentialGrowth_Dessler.html",
    "title": "Exponential Growth",
    "section": "",
    "text": "import numpy as np\n\n\n\n\\[ F = P (1 + rate/100)^n \\]\nwhere F is the future values, P is the initial value, rate is the percentage rate of increase (interest), and n is the number of years.\n\nP = 10000\nrate = 10\nn = 45\nF = P * (1 + rate/100)**n\n\nprint('Wow! That $100 investment really grew! It is $' + f'{F:.2f}' + ' after 101 years!')\n\n\n\n\nTo determine the doubling time, one can recognize that F/P is 2. So, then one can determine n if the rate is known.\n\\[ \\frac{F}{P} = 2 = (1 + r)^n \\]\nwhere r is the fractional rate of increase (not the percentage)\nTake the natural log of both sides of the equation.\n\\[ ln(2) = ln[(1 + r)^n] = n * ln(1 + r) \\]\nSo,\n\\[ n = \\frac{ln(2)}{ln(1 + r)} \\]\n\\[ n = \\frac{ln(2)}{r} \\frac{r}{ln(1 + r)} \\]\nIf r is small (e.g., 8% = 0.08), then\n\\[ \\frac{r}{ln(1 + r)} = \\frac{0.08}{ln(1 + 0.08)} = 1.03949 \\]\nand\n\\[ n \\approx \\frac{0.72}{r} \\approx \\frac{72}{100 * r} \\]\n\nr = 0.072\nnp.log(2) * r / np.log(1 + r)\n\nSo, if the rate of interest is constant at 7.2%, it will take 10 years to double your money."
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html#examples-from-introduction-to-modern-climate-change-by-andrew-dessler",
    "href": "chapter10/ExponentialGrowth_Dessler.html#examples-from-introduction-to-modern-climate-change-by-andrew-dessler",
    "title": "Exponential Growth",
    "section": "",
    "text": "import numpy as np\n\n\n\n\\[ F = P (1 + rate/100)^n \\]\nwhere F is the future values, P is the initial value, rate is the percentage rate of increase (interest), and n is the number of years.\n\nP = 10000\nrate = 10\nn = 45\nF = P * (1 + rate/100)**n\n\nprint('Wow! That $100 investment really grew! It is $' + f'{F:.2f}' + ' after 101 years!')\n\n\n\n\nTo determine the doubling time, one can recognize that F/P is 2. So, then one can determine n if the rate is known.\n\\[ \\frac{F}{P} = 2 = (1 + r)^n \\]\nwhere r is the fractional rate of increase (not the percentage)\nTake the natural log of both sides of the equation.\n\\[ ln(2) = ln[(1 + r)^n] = n * ln(1 + r) \\]\nSo,\n\\[ n = \\frac{ln(2)}{ln(1 + r)} \\]\n\\[ n = \\frac{ln(2)}{r} \\frac{r}{ln(1 + r)} \\]\nIf r is small (e.g., 8% = 0.08), then\n\\[ \\frac{r}{ln(1 + r)} = \\frac{0.08}{ln(1 + 0.08)} = 1.03949 \\]\nand\n\\[ n \\approx \\frac{0.72}{r} \\approx \\frac{72}{100 * r} \\]\n\nr = 0.072\nnp.log(2) * r / np.log(1 + r)\n\nSo, if the rate of interest is constant at 7.2%, it will take 10 years to double your money."
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html#discounting",
    "href": "chapter10/ExponentialGrowth_Dessler.html#discounting",
    "title": "Exponential Growth",
    "section": "Discounting",
    "text": "Discounting\nDiscounting simply solves our original equation for P.\n\\[ P = \\frac{F}{(1 + rate/100)^n} \\]\nThe value today of a future expense or benefit is known as the present value. The process of calculating the present value is referred to as discounting. “Money today is worth more to you than money in the future.”\n\nThe utility of discounting is that it allows one to compare costs and benefits that occur at different times.\n\nHow much would we need to invest to have $25,000 in 15 years at a 5% interest rate.\n\nF = 25000\nrate = 5\nn = 15\nP = F / (1 + rate/100)**n\n\nprint(f'We would need to invest ${P:.2f} now (at 5%) to have $25000 in 15 years.')\nprint()\nprint(f'${P:.2f} is the present value.')\nprint('This calculation is called discounting.')\nprint()\nprint('The rate of 5% is called the discount rate, because it quantifies the rate at which money loses value in the future.')\nprint('In other words, money loses 5% of its value each year.')\n\n\n\n\nExample 10.1: What would you do? The TV example!\nDiscounting can be used to help make financial decisions.\nLet’s say you’re buying a new TV and you’re given two payment options:\n\nPay $1000. now.\nGet it with no money down and pay $1100. in 1 year.\n\nWhich option is best for you?\n\n# No discounting.\nprint('You pay $1000. now, so it costs you $1000. in dollars today. So, the present value is $1000.')\n\nBut what is the present value of $1100. in one year.\n\n# Discount option at 5% in one year\nP = 1000\ndiscountRate = 5\nn = 1\nF = P * (1 + discountRate/100)**n\n\nprint('The value of the money after 1 year AT A DISCOUNT RATE OF 5% is $' + f'{F:.2f}')\n\nThe option that costs you the least amount of money is the one with the lowest present value.\nTherefore, you choose to pay $1000. now (because the present value of $1100. in one year from now, discounted at 5%, is $1050.)\nBut what if the discount rate is higher, say 15%?\n\nF = 1100\ndiscountRate = 15\nn = 1\nP = F / (1 + discountRate/100)**n\n\nprint('The value of the money after 1 year AT A DISCOUNT RATE OF 15% is $' + f'{P:.2f}')\n\nNow the option that costs you the least amount of money is the present value using the 15% discount rate.\nTherefore, you choose to pay $1100. next year because it will only cost you $956 in today’s dollars.\n\n\nThe choice of discount rate makes a profound difference in what you choose to do.\n\n\n\nCost-Benefit Analysis\nImagine our choice is between spending $100 billion today or $1 trillion in 100 years. Compare these two using a discount rate of 3%.\n\nrate = 3\nF = 1e12\nn = 100\nP = F / (1 + rate/100)**n\n\nprint('The value of the money after 100 years AT A DISCOUNT RATE OF 3% is $' + f'{P:.2f}')\n\nNote that this equals only $52 billion, so we would prefer to pay $1 trillion in 100 years than pay $100 billion today"
  },
  {
    "objectID": "chapter10/ExponentialGrowth_Dessler.html#so-how-do-we-determine-the-correct-discount-rate-to-use",
    "href": "chapter10/ExponentialGrowth_Dessler.html#so-how-do-we-determine-the-correct-discount-rate-to-use",
    "title": "Exponential Growth",
    "section": "So how do we determine the correct discount rate to use?",
    "text": "So how do we determine the correct discount rate to use?\nThe discount rate is a combination of two different judgements:\n\nTime discounting, which is the preference to consume now rather than later. Positive time discounting means that goods and services now are worth more than they are later.\nGrowth discounting is the fact that a dollar means more to poor people than it does to rich people. Would you pick up a $1 bill if you saw it on the street? What about a $20 bill?\n\nThe discount rate used in present-value calculations is determined by combining the time and growth discount rates.\nBUT economists argue about which rate to use: 1% to 4%.\n\nThe choice of discount rate makes a huge difference in climate problems."
  },
  {
    "objectID": "chapter0/softwareCarpentry_AnalyzingPatientData.html",
    "href": "chapter0/softwareCarpentry_AnalyzingPatientData.html",
    "title": "Software Carpentry - Analyzing Patient Data",
    "section": "",
    "text": "Software Carpentry - Analyzing Patient Data\nRead Software Carpentry’s Analyzing Patient Data.\nUsing notebook cells below, type in the commands in the instructions to check your knowledge of Python variables. (The two cells below will get you started.)\n\nimport numpy\n\n\nnumpy.loadtxt(fname='inflammation-01.csv', delimiter=',')",
    "crumbs": [
      "Python Fundamentals",
      "Software Carpentry - Analyzing Patient Data"
    ]
  },
  {
    "objectID": "chapter1/HoustonTemperatures.html",
    "href": "chapter1/HoustonTemperatures.html",
    "title": "Comparing temperature distributions",
    "section": "",
    "text": "Comparing temperature distributions\n© Von P. Walden, Washington State University\nThis notebook compares two distributions that differ slightly in their mean values. The idea is to simulate the two distributions in Figure 1.1 in Dessler’s book, and to then subtract the distributions to show where they differ the most.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nimport statistics\n\n\nGenerate two distributions of temperatures that approximate those measured in Houston, TX in the 1970s and 2010s.\n\n# ....These distributions roughly approximate those in Figure 1.1 in Dessler's Introduction to Modern Climate Change\nx = np.arange(21, 43, 0.1)\nH1970s = norm.pdf(x, 31, 2.75)\nH2010s = norm.pdf(x, 33, 2.75)\n\n\nplt.figure(figsize=(12,12))\nplt.subplot(211)\nplt.plot(x, H1970s)\nplt.plot(x, H2010s)\nplt.grid(True)\nplt.xlabel('Temperature (C)')\nplt.ylabel('Frequency')\nplt.title('Approximate Temperature Distributions for September near Houston, TX')\nplt.legend(['1970s', '2010s'])\nplt.subplot(212)\nplt.plot(x, H2010s-H1970s)\nplt.xlabel('Temperature (C)')\nplt.ylabel('Frequency')\nplt.title('Difference of the two temperature distributions')\nplt.grid(True)",
    "crumbs": [
      "Chapter 1",
      "Comparing temperature distributions"
    ]
  },
  {
    "objectID": "chapter0/softwareCarpentry_PythonFundamentals.html",
    "href": "chapter0/softwareCarpentry_PythonFundamentals.html",
    "title": "Software Carpentry - Python Fundamentals",
    "section": "",
    "text": "Software Carpentry - Python Fundamentals\nRead Software Carpentry’s Python Fundamentals. Start by scrolling down to the section on Variables.\nUsing notebook cells below, type in the commands in the instructions to check your knowledge of Python variables. (The cell below is the first example.)\n\n3 + 5 * 4",
    "crumbs": [
      "Python Fundamentals",
      "Software Carpentry - Python Fundamentals"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Notebooks",
    "section": "",
    "text": "© Von P. Walden, Washington State University\nThese computational notebooks were developed by Von P. Walden at Washington State University as part of the course CE401 - Climate Change Science and Engineering. Some of the notebooks are closely associated with Andrew Dessler’s book, Introduction to Modern Climate Change, and are designed to provide engineering students with more background in how to calculate parameters that are related to Earth’s climate and climate change.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Computational Notebooks",
    "section": "",
    "text": "© Von P. Walden, Washington State University\nThese computational notebooks were developed by Von P. Walden at Washington State University as part of the course CE401 - Climate Change Science and Engineering. Some of the notebooks are closely associated with Andrew Dessler’s book, Introduction to Modern Climate Change, and are designed to provide engineering students with more background in how to calculate parameters that are related to Earth’s climate and climate change.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "chapter2/LaurentideIceSheet_and_SeaLevel.html",
    "href": "chapter2/LaurentideIceSheet_and_SeaLevel.html",
    "title": "Laurentide Ice Sheet and Sea Level",
    "section": "",
    "text": "Approximate the Decrease in Sea-level from the Laurentide Ice Sheet\n© Von P. Walden, Washington State University\nThis notebook does a quick calculation of how much ice was contained in the Laurentide Ice Sheet about 20,000 years ago, and how that may have affected sea level at that time.\n\n# Approximate the volume of water in the Laurentide Ice Sheet\nsurface_area_of_Canada     = 10e6       # km^2\naverage_height_of_icesheet = 1.750      # km\nvolume_of_ice              = surface_area_of_Canada * average_height_of_icesheet\n\n# Assume the density of ice in the Laurentide\nrho_ice                    = 917        # kg m-3\nrho_water                  = 1000       # kg m-3\n\nvolume_of_water            = volume_of_ice * (rho_water / rho_ice)\n\n\nprint(\"The estimated volume of water in the Laurentide ice sheet is:\", volume_of_water, \"km^3\")\n\nThe estimated volume of water in the Laurentide ice sheet is: 19083969.465648852 km^3\n\n\n\n# Now divide by the surface area of oceans on earth to get the depth of water required to create the ice sheet.\nsurface_area_of_oceans     = 361e6        # km^2\nsea_level_change           = volume_of_water / surface_area_of_oceans * 1000   # meters\n\n\nprint(f'Decrease in sea level due to the Laurentide Ice Sheet: {sea_level_change:{5.3}} meters')\n\nDecrease in sea level due to the Laurentide Ice Sheet:  52.9 meters\n\n\n\nThe actual value at the height of the last ice age was actually about 120 meters.\nSea Level Rise, After the Ice Melted and Today\n\nWhere might we have underestimated our calculation? The density of ice !!\nSo find the necessary density of ice to get 120 meters of sea level.\n\nnew_rho_of_ice = volume_of_ice * (rho_water) / (surface_area_of_oceans * 120/1000)\n\n\nnew_rho_of_ice\n\n\n\n\nSo the density of ice would have had to be much lower; 400 kg/m^3.",
    "crumbs": [
      "Chapter 2",
      "Laurentide Ice Sheet and Sea Level"
    ]
  },
  {
    "objectID": "chapter3/PowerEmittedByHuman.html",
    "href": "chapter3/PowerEmittedByHuman.html",
    "title": "Power Emitted by a Human",
    "section": "",
    "text": "Calculate the Power Emitted by a Human\n© Von P. Walden, Washington State University\nEstimate the power (in W) given off by an average human being if they consume 2000 calories of food each day.\n\ncalories_per_day   = 2000\njoules_per_calorie = 4184\nseconds_per_day    = 24 * 60 * 60\n\npower_per_human    = calories_per_day * joules_per_calorie / seconds_per_day\n\n\nprint(f'The power emitted by an average human is {power_per_human:{4.3}} W m-2')\n\nThe power emitted by an average human is 96.9 W m-2"
  },
  {
    "objectID": "chapter3/BodiesEmittingInARoom.html",
    "href": "chapter3/BodiesEmittingInARoom.html",
    "title": "Bodies Emitting in a Room",
    "section": "",
    "text": "Bodies Emitting in a Room\n© Von P. Walden, Washington State University\n\nStefan-Boltzmann constant\n\ns = 5.67e-8                     # W m-2 K-4\n\n\n\nRadiation from the walls of the room\n\nTroom = 20 + 273.15             # K\nFlux_room = s * Troom**4            # W m-2\n\nprint(f\"The room radiates approximately {Flux_room:5.1f} W m-2\")\n\n\n\nRadiation from the bodies in the room\n\nTbody = 28 + 273.15             # K\nFlux_body = s * Tbody**4            # W m-2\n\nprint(f\"Bodies radiate at approximately {Flux_body:5.1f} W m-2\")\n\n\nActual Body Temperature (in deg C)\n\n(37 * 9/5) + 32\n\n\n\n\nRadiation from the bodies in the room (including emissivity)\n\ne     = 0.89\nTbody = 37 + 273.15             # K\nFlux_body = e * s * Tbody**4            # W m-2\n\nprint(f\"Bodies radiate at approximately {Flux_body:5.1f} W m-2\")\n\n\nSo if the emissivity of our bodies is 0.89 (or 89%), then we emit the same radiation as a blackbody at 28 C."
  },
  {
    "objectID": "chapter4/Insolation.html",
    "href": "chapter4/Insolation.html",
    "title": "Insolation",
    "section": "",
    "text": "Insolation\n© Von P. Walden, Washington State University\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nCalculates the insolation at the top of the atmosphere (TOA) as a function of time and location.\n\nSolar flux per unit area at TOA (Equations from Hartmann, Global Physical Climatology)\n\\[Q = S_o (d_m/d)^2 \\cos(\\theta_s)\\] where So is the solar “constant”, \\(d_m\\) is the mean distance between the Earth and Sun, d is the actual distance between the Earth and Sun, and theta(s) is the solar zenith angle.\n\\(\\delta = -23.44^{\\circ}\\cos{[(t_j+10 days)*(360^{\\circ}/365.25 days)]}\\) is the declination angle.\n\\(\\cos{\\theta_s} = \\sin{\\phi}sin{\\delta} + \\cos{\\phi}\\cos{\\delta}\\cos{h}\\), where phi is the latitude and h is the hour angle.\n\\(h=(12-t)*(15^{\\circ} / 1 hour)\\), where t is the local time and 15 is the number of degrees that the Earth rotates in one hour. The conversion factor converts hours to degrees.\n\\(d_m\\) is the mean distance from the Sun to the Earth, and is equal to the length of semi-major axis (a) of the elliptical orbit (which is 149.6 million km).\nd is the distance between the Earth and Sun on any given day, where the closest approach (perihelion) occurs on 3 January.\n\\[ d = \\frac{a(1-\\epsilon^2)}{1 + \\epsilon cos(\\theta)} \\]\nwhere \\(\\epsilon\\) is the eccentricity of Earth’s orbit (0.017), a is the semi major axis of Earth’s orbit, and \\(\\theta\\) is an angle that relates the day number to the correct location of Earth in the elliptical orbit for that day.\n\\(Q_{dayavg} = (S_o/\\pi)(d_m/d)^2[h_o\\sin{\\phi}\\sin{\\delta}+\\cos{\\phi}\\cos{\\delta}\\sin{h_o}]\\), where cos(\\(h_o) = -\\tan{\\phi}\\tan{\\delta}\\).\n\ndef earth_sun_distance(day):\n    a     = 149.6e6                   # km\n    e     = 0.017\n    theta = (day - 3) * ((2*np.pi) / 365.25)     # This is only an approximation.\n    d = a*(1-e*e)/(1+e * np.cos(theta))\n    return d\n\n\ndef declination(day):\n    dec = -23.44 * np.cos( (2.*np.pi) / 365.25 * (day + 10) )   # Approximate\n    return dec\n\n\ndef solar_zenith_angle(latitude,declinationAngle,hour):\n    # All angles must be in radians !!\n    latitude = latitude * (np.pi/180.)\n    declinationAngle = declinationAngle * (np.pi/180.)\n    h = 15. * (12. - hour) * (np.pi/180.)\n    sza = np.arccos(np.sin(latitude)*np.sin(declinationAngle) + np.cos(latitude)*np.cos(declinationAngle)*np.cos(h))\n    return sza\n\n\ndef Qday_avg(latitude,day):\n    lat = latitude*(np.pi/180.)\n    So  = 1370.\n    d   = earth_sun_distance(day)\n    dm  = 149.6e6\n    da  = declination(day) * (np.pi/180.)\n    tmp = np.tan(lat)*np.tan(da)\n    # Obtain this condition from http://en.wikipedia.org/wiki/Insolation\n    if tmp&gt;1:\n        ho = np.pi\n    elif tmp&lt;-1:\n        ho = 0.\n    else:\n        ho  = np.arccos(-1.*np.tan(lat)*np.tan(da))\n    Q   = (So/np.pi) * (dm/d)**2 * (ho*np.sin(lat)*np.sin(da) + np.cos(lat)*np.cos(da)*np.sin(ho))\n    return Q\n\n\nlat = 46.7\nday = 31+28+22\nprint('Declination = ', declination(day))\nprint('Earth distance = ', earth_sun_distance(day))\nprint('Q =', Qday_avg(lat, day))\n\nDeclination =  -0.12600714770976626\nEarth distance =  148981817.36070523\nQ = 300.456485702979\n\n\n\n\n\nGeographic distribution of insolation (solar radition) at TOA\n\nlats = np.arange(-90.,91.)\ndays = np.arange(1.,366.)\n\nQ = np.array([])\nfor lat in lats:\n    for day in days:\n        Q = np.append(Q, Qday_avg(lat,day))\n\nQn = np.reshape(Q,(181,365))\nplt.figure(figsize=(20,10))\n#CS=contourf(days, lats, Qn, range(0,550,50), cmap=plt.cm.RdBu_r)\nCS=plt.contour(days, lats, Qn, range(0,550,25), colors='k')\nplt.clabel(CS, range(0,550,100) ,inline=1,fmt='%4.0f',fontsize=12)\nplt.grid()\nplt.xlabel('Day of Year');\nplt.ylabel('Latitude (deg)');\nplt.title('TOA Insolation as a function of Day of Year and Latitude');\n\n\n\n\n\n\n\n\n\nmar20 = 31+28+20\njun21 = 31+28+31+30+31+21\nsep20 = 31+28+31+30+31+30+31+31+20\ndec21 = 355\nplt.figure(figsize=(20,10))\nplt.plot(lats,Qn[:,jun21],'r',lats,Qn[:,dec21],'b')\nplt.plot(lats,Qn[:,mar20],'r--',lats,Qn[:,sep20],'b--')\n#plt.plot(lats,Qn.mean(axis=1),'k')                      # Annual mean\nplt.axis([-90., 90., 0., 600])\nplt.grid()\nplt.xticks(np.arange(-90., 90.+1, 30.))\nplt.xlabel('Latitude (degrees)');\nplt.ylabel('Insolation (W m-2)');\nplt.title('Insolation for the Solstices and Equinoxes');\nplt.legend(['June Solstice', 'December Solstice', 'March Equinox', 'September Equinox'])\n\n\n\n\n\n\n\n\n\n\nDaily Average Insolation over Pullman, WA\n\ndays = np.arange(1.,366.)\nlat  = 46.7298\nlon  = -117.1817\n\nQ = np.array([])\nfor day in days:\n    Q = np.append(Q, Qday_avg(lat,day))\n\nplt.figure(figsize=(12,6))\nplt.plot(days, Q)\nplt.grid();\nplt.xlabel('Day of Year');\nplt.ylabel('Daily-Average Insolation (W m-2)');\nplt.title('TOA Insolation over Pullman, WA');\n\n\n\n\n\n\n\n\n\n\nHourly Insolation over Pullman, WA\n\nlatitude = 46.7\n#day      = 31+28+21                                 # 21 Mar\nday      = 31+28+31+30+31+21                        # 21 Jun\n#day      = 31+28+31+30+31+30+31+31+21               # 21 Sep\n#day      = 31+28+31+30+31+30+31+31+30+31+30+21      # 21 Dec\nhours    = np.arange(0,24.1,0.1)\ndm       = 149.6e6\nd        = earth_sun_distance(day)\ndec      = declination(day)\n\nQ = np.array([])\nfor hour in hours:\n    if np.cos(solar_zenith_angle(latitude, dec, hour)) &gt; 0:\n        Q = np.append(Q, 1361. * (dm/d)**2 * np.cos(solar_zenith_angle(latitude, dec, hour)))\n    else:\n        Q = np.append(Q, np.nan)\n        \n\nplt.figure(figsize=(12,6))\nplt.plot(hours, Q)\nplt.grid();\nplt.xlabel('Hour of Day');\nplt.ylabel('Insolation (W m-2)');\nplt.title('TOA Insolation over Pullman, WA');"
  },
  {
    "objectID": "chapter4/ASHRAE_Irradiance.html",
    "href": "chapter4/ASHRAE_Irradiance.html",
    "title": "ASHRAE Irradiance sample calculation",
    "section": "",
    "text": "ASHRAE Irradiance sample calculation\n\nimport numpy as np\nimport pandas as pd\nimport hvplot.pandas\n\nimport matplotlib.pyplot as plt\n\nASHRAE provides a formula for calculating the irradiance at the surface on a plane that is perpendicular to the incoming solar radiation. This equation is:\n\\[ I_B = A e^{-Km} \\]\nwhere\n\\[ A = 1160 + 75 sin[360(n - 275)/365] \\]\n\\[ K = 0.174 + 0.035 sin[360(n - 100)/365] \\]\n\\[ m = 1/ sin(\\beta) \\]\n\\[ \\beta = 90 - Latitude + Declination \\]\n\\[ Declination = \\delta = 23.45 sin[360/365 (n - 81)] \\]\nand n is the day number (e.g., May 1 = 31 + 28 + 31 + 30 + 1 = 121). A is the irradiance (W m-2), K is the attenuation per air mass, and m is the air mass.\n\ndef declination(day):\n    d = -23.44 * np.cos( (2.*np.pi) / 365.25 * (day + 10) )   # Approximate\n    return d\n\n\ndef declination(day):\n    d = 23.44 * np.cos( (2.*np.pi) / 365.25 * (day - 81) )   # Approximate\n    return d\n\n\ndef A(n):\n    return 1160. + 75.*np.sin(360/365*(n-275)*np.pi/180) # W m-2\n\n\ndef K(n):\n    return 0.174 +0.035*np.sin(360/365*(n-100)*np.pi/180) # unitless\n\n\ndef m(latitude, declination):\n    return 1. / np.sin((90. - latitude + declination)*np.pi/180)\n\n\ndays = np.arange(0,366)\ndec = []\nfor day in days:\n    dec.append(declination(day))\ndec = np.array(dec)\n\nplt.figure(figsize=(12,6))\nplt.plot(days, dec)\nplt.grid();\nplt.xlabel('Day of Year');\nplt.ylabel('Declination');\n\n\nA(121)\n\n\nK(121)\n\n\ndeclination(121)\n\n\nm(46.73, declination(121))\n\n\nlat = 46.73\nday = 121\ndec = declination(day)\nIb = A(day) * np.exp(-K(day)*m(lat, dec))\nprint('The ASHRAE irradiance at the surface is %4.0f W m-2'% Ib)\n\n\nNow create an annual cycle of solar radiation\n\ndates = pd.date_range('2023-01-01', '2023-12-31', freq='d')\n\n\ndec = []\nIb  = []\nfor date in dates:\n    day = int(date.strftime('%-j'))\n    dec.append(declination(day))\n    Ib.append(A(day) * np.exp(-K(day)*m(lat, dec[-1])))\ndec = np.array(dec)\ndf = pd.DataFrame({'declination': dec, 'irradiance': Ib})\ndf.index = dates\n\n\ndf.declination.plot(figsize=(16,6), grid=True)\n\n\ndf.irradiance.plot(figsize=(16,6), grid=True)\n\nNOTE THAT this is the solar radiation (in W m-2) on a surface that is always perpendicular to the sunlight. This is quite different from the TOA insolation that we calculated before. See the figures in the Solar Radiation Calculator for another example."
  }
]